// deno-lint-ignore-file
/* eslint-disable */
// Generated from https://raw.githubusercontent.com/grafana/grafana/v10.4.1/public/openapi3.json
/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/access-control/assignments/search": {
    /**
     * Returns the result of the search through access-control role assignments.
     *
     * You need to have a permission with action `teams.roles:read` on scope `teams:*`
     * and a permission with action `users.roles:read` on scope `users:*`.
     */
    post: operations["searchResult"];
  };
  "/access-control/roles": {
    /**
     * Gets all existing roles. The response contains all global and organization local roles, for the organization which user is signed in.
     *
     * You need to have a permission with action `roles:read` and scope `roles:*`.
     */
    get: operations["listRoles"];
    /**
     * Creates a new custom role and maps given permissions to that role. Note that roles with the same prefix as Fixed Roles can’t be created.
     *
     * You need to have a permission with action `roles:write` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only create custom roles with the same, or a subset of permissions which the user has.
     * For example, if a user does not have required permissions for creating users, they won’t be able to create a custom role which allows to do that. This is done to prevent escalation of privileges.
     */
    post: operations["createRole"];
  };
  "/access-control/roles/{roleUID}": {
    /**
     * Get a role for the given UID.
     *
     * You need to have a permission with action `roles:read` and scope `roles:*`.
     */
    get: operations["getRole"];
    /** You need to have a permission with action `roles:write` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only create custom roles with the same, or a subset of permissions which the user has. */
    put: operations["updateRole"];
    /**
     * Delete a role with the given UID, and it’s permissions. If the role is assigned to a built-in role, the deletion operation will fail, unless force query param is set to true, and in that case all assignments will also be deleted.
     *
     * You need to have a permission with action `roles:delete` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only delete a custom role with the same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to delete a custom role which allows to do that.
     */
    delete: operations["deleteRole"];
  };
  "/access-control/roles/{roleUID}/assignments": {
    /**
     * Get role assignments for the role with the given UID.
     *
     * You need to have a permission with action `teams.roles:list` and scope `teams:id:*` and `users.roles:list` and scope `users:id:*`.
     */
    get: operations["getRoleAssignments"];
    /**
     * Set role assignments for the role with the given UID.
     *
     * You need to have a permission with action `teams.roles:add` and `teams.roles:remove` and scope `permissions:type:delegate`, and `users.roles:add` and `users.roles:remove` and scope `permissions:type:delegate`.
     */
    put: operations["setRoleAssignments"];
  };
  "/access-control/status": {
    /**
     * Returns an indicator to check if fine-grained access control is enabled or not.
     *
     * You need to have a permission with action `status:accesscontrol` and scope `services:accesscontrol`.
     */
    get: operations["getAccessControlStatus"];
  };
  "/access-control/teams/roles/search": {
    /**
     * Lists the roles that have been directly assigned to the given teams.
     *
     * You need to have a permission with action `teams.roles:read` and scope `teams:id:*`.
     */
    post: operations["listTeamsRoles"];
  };
  "/access-control/teams/{teamId}/roles": {
    /** You need to have a permission with action `teams.roles:read` and scope `teams:id:<team ID>`. */
    get: operations["listTeamRoles"];
    /** You need to have a permission with action `teams.roles:add` and `teams.roles:remove` and scope `permissions:type:delegate` for each. */
    put: operations["setTeamRoles"];
    /** You need to have a permission with action `teams.roles:add` and scope `permissions:type:delegate`. */
    post: operations["addTeamRole"];
  };
  "/access-control/teams/{teamId}/roles/{roleUID}": {
    /** You need to have a permission with action `teams.roles:remove` and scope `permissions:type:delegate`. */
    delete: operations["removeTeamRole"];
  };
  "/access-control/users/roles/search": {
    /**
     * Lists the roles that have been directly assigned to the given users. The list does not include built-in roles (Viewer, Editor, Admin or Grafana Admin), and it does not include roles that have been inherited from a team.
     *
     * You need to have a permission with action `users.roles:read` and scope `users:id:*`.
     */
    post: operations["listUsersRoles"];
  };
  "/access-control/users/{userId}/roles": {
    /**
     * Lists the roles that have been directly assigned to a given user. The list does not include built-in roles (Viewer, Editor, Admin or Grafana Admin), and it does not include roles that have been inherited from a team.
     *
     * You need to have a permission with action `users.roles:read` and scope `users:id:<user ID>`.
     */
    get: operations["listUserRoles"];
    /**
     * Update the user’s role assignments to match the provided set of UIDs. This will remove any assigned roles that aren’t in the request and add roles that are in the set but are not already assigned to the user.
     * If you want to add or remove a single role, consider using Add a user role assignment or Remove a user role assignment instead.
     *
     * You need to have a permission with action `users.roles:add` and `users.roles:remove` and scope `permissions:type:delegate` for each. `permissions:type:delegate`  scope ensures that users can only assign or unassign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to assign or unassign a role which will allow to do that. This is done to prevent escalation of privileges.
     */
    put: operations["setUserRoles"];
    /**
     * Assign a role to a specific user. For bulk updates consider Set user role assignments.
     *
     * You need to have a permission with action `users.roles:add` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only assign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to assign a role which will allow to do that. This is done to prevent escalation of privileges.
     */
    post: operations["addUserRole"];
  };
  "/access-control/users/{userId}/roles/{roleUID}": {
    /**
     * Revoke a role from a user. For bulk updates consider Set user role assignments.
     *
     * You need to have a permission with action `users.roles:remove` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only unassign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to unassign a role which will allow to do that. This is done to prevent escalation of privileges.
     */
    delete: operations["removeUserRole"];
  };
  "/access-control/{resource}/description": {
    get: operations["getResourceDescription"];
  };
  "/access-control/{resource}/{resourceID}": {
    get: operations["getResourcePermissions"];
    /**
     * Assigns permissions for a resource by a given type (`:resource`) and `:resourceID` to one or many
     * assignment types. Allowed resources are `datasources`, `teams`, `dashboards`, `folders`, and `serviceaccounts`.
     * Refer to the `/access-control/{resource}/description` endpoint for allowed Permissions.
     */
    post: operations["setResourcePermissions"];
  };
  "/access-control/{resource}/{resourceID}/builtInRoles/{builtInRole}": {
    /**
     * Assigns permissions for a resource by a given type (`:resource`) and `:resourceID` to a built-in role.
     * Allowed resources are `datasources`, `teams`, `dashboards`, `folders`, and `serviceaccounts`.
     * Refer to the `/access-control/{resource}/description` endpoint for allowed Permissions.
     */
    post: operations["setResourcePermissionsForBuiltInRole"];
  };
  "/access-control/{resource}/{resourceID}/teams/{teamID}": {
    /**
     * Assigns permissions for a resource by a given type (`:resource`) and `:resourceID` to a team.
     * Allowed resources are `datasources`, `teams`, `dashboards`, `folders`, and `serviceaccounts`.
     * Refer to the `/access-control/{resource}/description` endpoint for allowed Permissions.
     */
    post: operations["setResourcePermissionsForTeam"];
  };
  "/access-control/{resource}/{resourceID}/users/{userID}": {
    /**
     * Assigns permissions for a resource by a given type (`:resource`) and `:resourceID` to a user or a service account.
     * Allowed resources are `datasources`, `teams`, `dashboards`, `folders`, and `serviceaccounts`.
     * Refer to the `/access-control/{resource}/description` endpoint for allowed Permissions.
     */
    post: operations["setResourcePermissionsForUser"];
  };
  "/admin/ldap-sync-status": {
    /** You need to have a permission with action `ldap.status:read`. */
    get: operations["getSyncStatus"];
  };
  "/admin/ldap/reload": {
    /** If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `ldap.config:reload`. */
    post: operations["reloadLDAPCfg"];
  };
  "/admin/ldap/status": {
    /** If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `ldap.status:read`. */
    get: operations["getLDAPStatus"];
  };
  "/admin/ldap/sync/{user_id}": {
    /** If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `ldap.user:sync`. */
    post: operations["postSyncUserWithLDAP"];
  };
  "/admin/ldap/{user_name}": {
    /** If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `ldap.user:read`. */
    get: operations["getUserFromLDAP"];
  };
  "/admin/pause-all-alerts": {
    post: operations["pauseAllAlerts"];
  };
  "/admin/provisioning/access-control/reload": {
    post: operations["adminProvisioningReloadAccessControl"];
  };
  "/admin/provisioning/dashboards/reload": {
    /**
     * Reloads the provisioning config files for dashboards again. It won’t return until the new provisioned entities are already stored in the database. In case of dashboards, it will stop polling for changes in dashboard files and then restart it with new configurations after returning.
     * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `provisioning:reload` and scope `provisioners:dashboards`.
     */
    post: operations["adminProvisioningReloadDashboards"];
  };
  "/admin/provisioning/datasources/reload": {
    /**
     * Reloads the provisioning config files for datasources again. It won’t return until the new provisioned entities are already stored in the database. In case of dashboards, it will stop polling for changes in dashboard files and then restart it with new configurations after returning.
     * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `provisioning:reload` and scope `provisioners:datasources`.
     */
    post: operations["adminProvisioningReloadDatasources"];
  };
  "/admin/provisioning/notifications/reload": {
    /**
     * Reloads the provisioning config files for legacy alert notifiers again. It won’t return until the new provisioned entities are already stored in the database. In case of dashboards, it will stop polling for changes in dashboard files and then restart it with new configurations after returning.
     * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `provisioning:reload` and scope `provisioners:notifications`.
     */
    post: operations["adminProvisioningReloadNotifications"];
  };
  "/admin/provisioning/plugins/reload": {
    /**
     * Reloads the provisioning config files for plugins again. It won’t return until the new provisioned entities are already stored in the database. In case of dashboards, it will stop polling for changes in dashboard files and then restart it with new configurations after returning.
     * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `provisioning:reload` and scope `provisioners:plugin`.
     */
    post: operations["adminProvisioningReloadPlugins"];
  };
  "/admin/settings": {
    /** If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `settings:read` and scopes: `settings:*`, `settings:auth.saml:` and `settings:auth.saml:enabled` (property level). */
    get: operations["adminGetSettings"];
  };
  "/admin/stats": {
    /**
     * Only works with Basic Authentication (username and password). See introduction for an explanation.
     * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `server:stats:read`.
     */
    get: operations["adminGetStats"];
  };
  "/admin/users": {
    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users:create`.
     * Note that OrgId is an optional parameter that can be used to assign a new user to a different organization when `auto_assign_org` is set to `true`.
     */
    post: operations["adminCreateUser"];
  };
  "/admin/users/{user_id}": {
    /** If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users:delete` and scope `global.users:*`. */
    delete: operations["adminDeleteUser"];
  };
  "/admin/users/{user_id}/auth-tokens": {
    /** If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.authtoken:list` and scope `global.users:*`. */
    get: operations["adminGetUserAuthTokens"];
  };
  "/admin/users/{user_id}/disable": {
    /** If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users:disable` and scope `global.users:1` (userIDScope). */
    post: operations["adminDisableUser"];
  };
  "/admin/users/{user_id}/enable": {
    /** If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users:enable` and scope `global.users:1` (userIDScope). */
    post: operations["adminEnableUser"];
  };
  "/admin/users/{user_id}/logout": {
    /** If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.logout` and scope `global.users:*`. */
    post: operations["adminLogoutUser"];
  };
  "/admin/users/{user_id}/password": {
    /** If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.password:update` and scope `global.users:*`. */
    put: operations["adminUpdateUserPassword"];
  };
  "/admin/users/{user_id}/permissions": {
    /**
     * Only works with Basic Authentication (username and password). See introduction for an explanation.
     * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.permissions:update` and scope `global.users:*`.
     */
    put: operations["adminUpdateUserPermissions"];
  };
  "/admin/users/{user_id}/quotas": {
    /** If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.quotas:list` and scope `global.users:1` (userIDScope). */
    get: operations["getUserQuota"];
  };
  "/admin/users/{user_id}/quotas/{quota_target}": {
    /** If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.quotas:update` and scope `global.users:1` (userIDScope). */
    put: operations["updateUserQuota"];
  };
  "/admin/users/{user_id}/revoke-auth-token": {
    /**
     * Revokes the given auth token (device) for the user. User of issued auth token (device) will no longer be logged in and will be required to authenticate again upon next activity.
     * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.authtoken:update` and scope `global.users:*`.
     */
    post: operations["adminRevokeUserAuthToken"];
  };
  "/alert-notifications": {
    /** Returns all notification channels that the authenticated user has permission to view. */
    get: operations["getAlertNotificationChannels"];
    /** You can find the full list of [supported notifiers](https://grafana.com/docs/grafana/latest/alerting/old-alerting/notifications/#list-of-supported-notifiers) on the alert notifiers page. */
    post: operations["createAlertNotificationChannel"];
  };
  "/alert-notifications/lookup": {
    /** Returns all notification channels, but with less detailed information. Accessible by any authenticated user and is mainly used by providing alert notification channels in Grafana UI when configuring alert rule. */
    get: operations["getAlertNotificationLookup"];
  };
  "/alert-notifications/test": {
    /** Sends a test notification to the channel. */
    post: operations["notificationChannelTest"];
  };
  "/alert-notifications/uid/{notification_channel_uid}": {
    /** Returns the notification channel given the notification channel UID. */
    get: operations["getAlertNotificationChannelByUID"];
    /** Updates an existing notification channel identified by uid. */
    put: operations["updateAlertNotificationChannelByUID"];
    /** Deletes an existing notification channel identified by UID. */
    delete: operations["deleteAlertNotificationChannelByUID"];
  };
  "/alert-notifications/{notification_channel_id}": {
    /** Returns the notification channel given the notification channel ID. */
    get: operations["getAlertNotificationChannelByID"];
    /** Updates an existing notification channel identified by ID. */
    put: operations["updateAlertNotificationChannel"];
    /** Deletes an existing notification channel identified by ID. */
    delete: operations["deleteAlertNotificationChannel"];
  };
  "/alerts": {
    get: operations["getAlerts"];
  };
  "/alerts/states-for-dashboard": {
    get: operations["getDashboardStates"];
  };
  "/alerts/test": {
    post: operations["testAlert"];
  };
  "/alerts/{alert_id}": {
    /**
     * “evalMatches” data in the response is cached in the db when and only when the state of the alert changes (e.g. transitioning from “ok” to “alerting” state).
     * If data from one server triggers the alert first and, before that server is seen leaving alerting state, a second server also enters a state that would trigger the alert, the second server will not be visible in “evalMatches” data.
     */
    get: operations["getAlertByID"];
  };
  "/alerts/{alert_id}/pause": {
    post: operations["pauseAlert"];
  };
  "/annotations": {
    /** Starting in Grafana v6.4 regions annotations are now returned in one entity that now includes the timeEnd property. */
    get: operations["getAnnotations"];
    /**
     * Creates an annotation in the Grafana database. The dashboardId and panelId fields are optional. If they are not specified then an organization annotation is created and can be queried in any dashboard that adds the Grafana annotations data source. When creating a region annotation include the timeEnd property.
     * The format for `time` and `timeEnd` should be epoch numbers in millisecond resolution.
     * The response for this HTTP request is slightly different in versions prior to v6.4. In prior versions you would also get an endId if you where creating a region. But in 6.4 regions are represented using a single event with time and timeEnd properties.
     */
    post: operations["postAnnotation"];
  };
  "/annotations/graphite": {
    /** Creates an annotation by using Graphite-compatible event format. The `when` and `data` fields are optional. If `when` is not specified then the current time will be used as annotation’s timestamp. The `tags` field can also be in prior to Graphite `0.10.0` format (string with multiple tags being separated by a space). */
    post: operations["postGraphiteAnnotation"];
  };
  "/annotations/mass-delete": {
    post: operations["massDeleteAnnotations"];
  };
  "/annotations/tags": {
    /** Find all the event tags created in the annotations. */
    get: operations["getAnnotationTags"];
  };
  "/annotations/{annotation_id}": {
    get: operations["getAnnotationByID"];
    /** Updates all properties of an annotation that matches the specified id. To only update certain property, consider using the Patch Annotation operation. */
    put: operations["updateAnnotation"];
    /** Deletes the annotation that matches the specified ID. */
    delete: operations["deleteAnnotationByID"];
    /**
     * Updates one or more properties of an annotation that matches the specified ID.
     * This operation currently supports updating of the `text`, `tags`, `time` and `timeEnd` properties.
     * This is available in Grafana 6.0.0-beta2 and above.
     */
    patch: operations["patchAnnotation"];
  };
  "/auth/keys": {
    /**
     * Will return auth keys.
     *
     * Deprecated: true.
     *
     * Deprecated. Please use GET /api/serviceaccounts and GET /api/serviceaccounts/{id}/tokens instead
     * see https://grafana.com/docs/grafana/next/administration/api-keys/#migrate-api-keys-to-grafana-service-accounts-using-the-api.
     */
    get: operations["getAPIkeys"];
    /** Will return details of the created API key. */
    post: operations["addAPIkey"];
  };
  "/auth/keys/{id}": {
    /**
     * Deletes an API key.
     * Deprecated. See: https://grafana.com/docs/grafana/next/administration/api-keys/#migrate-api-keys-to-grafana-service-accounts-using-the-api.
     */
    delete: operations["deleteAPIkey"];
  };
  "/dashboard/snapshots": {
    get: operations["searchDashboardSnapshots"];
  };
  "/dashboards/calculate-diff": {
    post: operations["calculateDashboardDiff"];
  };
  "/dashboards/db": {
    /**
     * Creates a new dashboard or updates an existing dashboard.
     * Note: This endpoint is not intended for creating folders, use `POST /api/folders` for that.
     */
    post: operations["postDashboard"];
  };
  "/dashboards/home": {
    get: operations["getHomeDashboard"];
  };
  "/dashboards/id/{DashboardID}/permissions": {
    /** Please refer to [updated API](#/dashboard_permissions/getDashboardPermissionsListByUID) instead */
    get: operations["getDashboardPermissionsListByID"];
    /**
     * Please refer to [updated API](#/dashboard_permissions/updateDashboardPermissionsByUID) instead
     *
     * This operation will remove existing permissions if they’re not included in the request.
     */
    post: operations["updateDashboardPermissionsByID"];
  };
  "/dashboards/id/{DashboardID}/restore": {
    /** Please refer to [updated API](#/dashboard_versions/restoreDashboardVersionByUID) instead */
    post: operations["restoreDashboardVersionByID"];
  };
  "/dashboards/id/{DashboardID}/versions": {
    /** Please refer to [updated API](#/dashboard_versions/getDashboardVersionsByUID) instead */
    get: operations["getDashboardVersionsByID"];
  };
  "/dashboards/id/{DashboardID}/versions/{DashboardVersionID}": {
    /** Please refer to [updated API](#/dashboard_versions/getDashboardVersionByUID) instead */
    get: operations["getDashboardVersionByID"];
  };
  "/dashboards/import": {
    post: operations["importDashboard"];
  };
  "/dashboards/public-dashboards": {
    /** Get list of public dashboards */
    get: operations["listPublicDashboards"];
  };
  "/dashboards/tags": {
    get: operations["getDashboardTags"];
  };
  "/dashboards/uid/{dashboardUid}/public-dashboards": {
    /** Get public dashboard by dashboardUid */
    get: operations["getPublicDashboard"];
    /** Create public dashboard for a dashboard */
    post: operations["createPublicDashboard"];
  };
  "/dashboards/uid/{dashboardUid}/public-dashboards/{uid}": {
    /** Delete public dashboard for a dashboard */
    delete: operations["deletePublicDashboard"];
    /** Update public dashboard for a dashboard */
    patch: operations["updatePublicDashboard"];
  };
  "/dashboards/uid/{uid}": {
    /** Will return the dashboard given the dashboard unique identifier (uid). */
    get: operations["getDashboardByUID"];
    /** Will delete the dashboard given the specified unique identifier (uid). */
    delete: operations["deleteDashboardByUID"];
  };
  "/dashboards/uid/{uid}/permissions": {
    get: operations["getDashboardPermissionsListByUID"];
    /** This operation will remove existing permissions if they’re not included in the request. */
    post: operations["updateDashboardPermissionsByUID"];
  };
  "/dashboards/uid/{uid}/restore": {
    post: operations["restoreDashboardVersionByUID"];
  };
  "/dashboards/uid/{uid}/versions": {
    get: operations["getDashboardVersionsByUID"];
  };
  "/dashboards/uid/{uid}/versions/{DashboardVersionID}": {
    get: operations["getDashboardVersionByUID"];
  };
  "/datasources": {
    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled
     * you need to have a permission with action: `datasources:read` and scope: `datasources:*`.
     */
    get: operations["getDataSources"];
    /**
     * By defining `password` and `basicAuthPassword` under secureJsonData property
     * Grafana encrypts them securely as an encrypted blob in the database.
     * The response then lists the encrypted fields under secureJsonFields.
     *
     * If you are running Grafana Enterprise and have Fine-grained access control enabled
     * you need to have a permission with action: `datasources:create`
     */
    post: operations["addDataSource"];
  };
  "/datasources/correlations": {
    get: operations["getCorrelations"];
  };
  "/datasources/id/{name}": {
    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled
     * you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:name:*` and `datasources:name:test_datasource` (single data source).
     */
    get: operations["getDataSourceIdByName"];
  };
  "/datasources/name/{name}": {
    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled
     * you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:name:*` and `datasources:name:test_datasource` (single data source).
     */
    get: operations["getDataSourceByName"];
    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled
     * you need to have a permission with action: `datasources:delete` and scopes: `datasources:*`, `datasources:name:*` and `datasources:name:test_datasource` (single data source).
     */
    delete: operations["deleteDataSourceByName"];
  };
  "/datasources/proxy/uid/{uid}/{datasource_proxy_route}": {
    /** Proxies all calls to the actual data source. */
    get: operations["datasourceProxyGETByUIDcalls"];
    /** Proxies all calls to the actual data source. The data source should support POST methods for the specific path and role as defined */
    post: operations["datasourceProxyPOSTByUIDcalls"];
    /** Proxies all calls to the actual data source. */
    delete: operations["datasourceProxyDELETEByUIDcalls"];
  };
  "/datasources/proxy/{id}/{datasource_proxy_route}": {
    /**
     * Proxies all calls to the actual data source.
     *
     * Please refer to [updated API](#/datasources/datasourceProxyGETByUIDcalls) instead
     */
    get: operations["datasourceProxyGETcalls"];
    /**
     * Proxies all calls to the actual data source. The data source should support POST methods for the specific path and role as defined
     *
     * Please refer to [updated API](#/datasources/datasourceProxyPOSTByUIDcalls) instead
     */
    post: operations["datasourceProxyPOSTcalls"];
    /**
     * Proxies all calls to the actual data source.
     *
     * Please refer to [updated API](#/datasources/datasourceProxyDELETEByUIDcalls) instead
     */
    delete: operations["datasourceProxyDELETEcalls"];
  };
  "/datasources/uid/{sourceUID}/correlations": {
    get: operations["getCorrelationsBySourceUID"];
    post: operations["createCorrelation"];
  };
  "/datasources/uid/{sourceUID}/correlations/{correlationUID}": {
    get: operations["getCorrelation"];
    patch: operations["updateCorrelation"];
  };
  "/datasources/uid/{uid}": {
    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled
     * you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:uid:*` and `datasources:uid:kLtEtcRGk` (single data source).
     */
    get: operations["getDataSourceByUID"];
    /**
     * Similar to creating a data source, `password` and `basicAuthPassword` should be defined under
     * secureJsonData in order to be stored securely as an encrypted blob in the database. Then, the
     * encrypted fields are listed under secureJsonFields section in the response.
     *
     * If you are running Grafana Enterprise and have Fine-grained access control enabled
     * you need to have a permission with action: `datasources:write` and scopes: `datasources:*`, `datasources:uid:*` and `datasources:uid:1` (single data source).
     */
    put: operations["updateDataSourceByUID"];
    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled
     * you need to have a permission with action: `datasources:delete` and scopes: `datasources:*`, `datasources:uid:*` and `datasources:uid:kLtEtcRGk` (single data source).
     */
    delete: operations["deleteDataSourceByUID"];
  };
  "/datasources/uid/{uid}/correlations/{correlationUID}": {
    delete: operations["deleteCorrelation"];
  };
  "/datasources/uid/{uid}/health": {
    get: operations["checkDatasourceHealthWithUID"];
  };
  "/datasources/uid/{uid}/resources/{datasource_proxy_route}": {
    get: operations["callDatasourceResourceWithUID"];
  };
  "/datasources/{id}": {
    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled
     * you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:id:*` and `datasources:id:1` (single data source).
     *
     * Please refer to [updated API](#/datasources/getDataSourceByUID) instead
     */
    get: operations["getDataSourceByID"];
    /**
     * Similar to creating a data source, `password` and `basicAuthPassword` should be defined under
     * secureJsonData in order to be stored securely as an encrypted blob in the database. Then, the
     * encrypted fields are listed under secureJsonFields section in the response.
     *
     * If you are running Grafana Enterprise and have Fine-grained access control enabled
     * you need to have a permission with action: `datasources:write` and scopes: `datasources:*`, `datasources:id:*` and `datasources:id:1` (single data source).
     *
     * Please refer to [updated API](#/datasources/updateDataSourceByUID) instead
     */
    put: operations["updateDataSourceByID"];
    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled
     * you need to have a permission with action: `datasources:delete` and scopes: `datasources:*`, `datasources:id:*` and `datasources:id:1` (single data source).
     *
     * Please refer to [updated API](#/datasources/deleteDataSourceByUID) instead
     */
    delete: operations["deleteDataSourceByID"];
  };
  "/datasources/{id}/health": {
    /** Please refer to [updated API](#/datasources/checkDatasourceHealthWithUID) instead */
    get: operations["checkDatasourceHealthByID"];
  };
  "/datasources/{id}/resources/{datasource_proxy_route}": {
    /** Please refer to [updated API](#/datasources/callDatasourceResourceWithUID) instead */
    get: operations["callDatasourceResourceByID"];
  };
  "/ds/query": {
    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled
     * you need to have a permission with action: `datasources:query`.
     */
    post: operations["queryMetricsWithExpressions"];
  };
  "/folders": {
    /**
     * Returns all folders that the authenticated user has permission to view.
     * If nested folders are enabled, it expects an additional query parameter with the parent folder UID
     * and returns the immediate subfolders that the authenticated user has permission to view.
     * If the parameter is not supplied then it returns immediate subfolders under the root
     * that the authenticated user has permission to view.
     */
    get: operations["getFolders"];
    /** If nested folders are enabled then it additionally expects the parent folder UID. */
    post: operations["createFolder"];
  };
  "/folders/id/{folder_id}": {
    /**
     * Returns the folder identified by id. This is deprecated.
     * Please refer to [updated API](#/folders/getFolderByUID) instead
     */
    get: operations["getFolderByID"];
  };
  "/folders/{folder_uid}": {
    get: operations["getFolderByUID"];
    put: operations["updateFolder"];
    /**
     * Deletes an existing folder identified by UID along with all dashboards (and their alerts) stored in the folder. This operation cannot be reverted.
     * If nested folders are enabled then it also deletes all the subfolders.
     */
    delete: operations["deleteFolder"];
  };
  "/folders/{folder_uid}/counts": {
    get: operations["getFolderDescendantCounts"];
  };
  "/folders/{folder_uid}/move": {
    post: operations["moveFolder"];
  };
  "/folders/{folder_uid}/permissions": {
    get: operations["getFolderPermissionList"];
    post: operations["updateFolderPermissions"];
  };
  "/library-elements": {
    /**
     * Returns a list of all library elements the authenticated user has permission to view.
     * Use the `perPage` query parameter to control the maximum number of library elements returned; the default limit is `100`.
     * You can also use the `page` query parameter to fetch library elements from any page other than the first one.
     */
    get: operations["getLibraryElements"];
    /** Creates a new library element. */
    post: operations["createLibraryElement"];
  };
  "/library-elements/name/{library_element_name}": {
    /** Returns a library element with the given name. */
    get: operations["getLibraryElementByName"];
  };
  "/library-elements/{library_element_uid}": {
    /** Returns a library element with the given UID. */
    get: operations["getLibraryElementByUID"];
    /**
     * Deletes an existing library element as specified by the UID. This operation cannot be reverted.
     * You cannot delete a library element that is connected. This operation cannot be reverted.
     */
    delete: operations["deleteLibraryElementByUID"];
    /** Updates an existing library element identified by uid. */
    patch: operations["updateLibraryElement"];
  };
  "/library-elements/{library_element_uid}/connections/": {
    /** Returns a list of connections for a library element based on the UID specified. */
    get: operations["getLibraryElementConnections"];
  };
  "/licensing/check": {
    get: operations["getStatus"];
  };
  "/licensing/custom-permissions": {
    /** You need to have a permission with action `licensing.reports:read`. */
    get: operations["getCustomPermissionsReport"];
  };
  "/licensing/custom-permissions-csv": {
    /** You need to have a permission with action `licensing.reports:read`. */
    get: operations["getCustomPermissionsCSV"];
  };
  "/licensing/refresh-stats": {
    /** You need to have a permission with action `licensing:read`. */
    get: operations["refreshLicenseStats"];
  };
  "/licensing/token": {
    /** You need to have a permission with action `licensing:read`. */
    get: operations["getLicenseToken"];
    /** You need to have a permission with action `licensing:update`. */
    post: operations["postLicenseToken"];
    /**
     * Removes the license stored in the Grafana database. Available in Grafana Enterprise v7.4+.
     *
     * You need to have a permission with action `licensing:delete`.
     */
    delete: operations["deleteLicenseToken"];
  };
  "/licensing/token/renew": {
    /**
     * Manually ask license issuer for a new token. Available in Grafana Enterprise v7.4+.
     *
     * You need to have a permission with action `licensing:update`.
     */
    post: operations["postRenewLicenseToken"];
  };
  "/logout/saml": {
    get: operations["getSAMLLogout"];
  };
  "/org": {
    get: operations["getCurrentOrg"];
    put: operations["updateCurrentOrg"];
  };
  "/org/address": {
    put: operations["updateCurrentOrgAddress"];
  };
  "/org/invites": {
    get: operations["getPendingOrgInvites"];
    post: operations["addOrgInvite"];
  };
  "/org/invites/{invitation_code}/revoke": {
    delete: operations["revokeInvite"];
  };
  "/org/preferences": {
    get: operations["getOrgPreferences"];
    put: operations["updateOrgPreferences"];
    patch: operations["patchOrgPreferences"];
  };
  "/org/quotas": {
    /** If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `orgs.quotas:read` and scope `org:id:1` (orgIDScope). */
    get: operations["getCurrentOrgQuota"];
  };
  "/org/users": {
    /**
     * Returns all org users within the current organization. Accessible to users with org admin role.
     * If you are running Grafana Enterprise and have Fine-grained access control enabled
     * you need to have a permission with action: `org.users:read` with scope `users:*`.
     */
    get: operations["getOrgUsersForCurrentOrg"];
    /**
     * Adds a global user to the current organization.
     *
     * If you are running Grafana Enterprise and have Fine-grained access control enabled
     * you need to have a permission with action: `org.users:add` with scope `users:*`.
     */
    post: operations["addOrgUserToCurrentOrg"];
  };
  "/org/users/lookup": {
    /**
     * Returns all org users within the current organization, but with less detailed information.
     * Accessible to users with org admin role, admin in any folder or admin of any team.
     * Mainly used by Grafana UI for providing list of users when adding team members and when editing folder/dashboard permissions.
     */
    get: operations["getOrgUsersForCurrentOrgLookup"];
  };
  "/org/users/{user_id}": {
    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled
     * you need to have a permission with action: `org.users:remove` with scope `users:*`.
     */
    delete: operations["removeOrgUserForCurrentOrg"];
    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled
     * you need to have a permission with action: `org.users.role:update` with scope `users:*`.
     */
    patch: operations["updateOrgUserForCurrentOrg"];
  };
  "/orgs": {
    get: operations["searchOrgs"];
    /** Only works if [users.allow_org_create](https://grafana.com/docs/grafana/latest/administration/configuration/#allow_org_create) is set. */
    post: operations["createOrg"];
  };
  "/orgs/name/{org_name}": {
    get: operations["getOrgByName"];
  };
  "/orgs/{org_id}": {
    get: operations["getOrgByID"];
    put: operations["updateOrg"];
    delete: operations["deleteOrgByID"];
  };
  "/orgs/{org_id}/address": {
    put: operations["updateOrgAddress"];
  };
  "/orgs/{org_id}/quotas": {
    /** If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `orgs.quotas:read` and scope `org:id:1` (orgIDScope). */
    get: operations["getOrgQuota"];
  };
  "/orgs/{org_id}/quotas/{quota_target}": {
    /** If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `orgs.quotas:write` and scope `org:id:1` (orgIDScope). */
    put: operations["updateOrgQuota"];
  };
  "/orgs/{org_id}/users": {
    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled
     * you need to have a permission with action: `org.users:read` with scope `users:*`.
     */
    get: operations["getOrgUsers"];
    /**
     * Adds a global user to the current organization.
     *
     * If you are running Grafana Enterprise and have Fine-grained access control enabled
     * you need to have a permission with action: `org.users:add` with scope `users:*`.
     */
    post: operations["addOrgUser"];
  };
  "/orgs/{org_id}/users/search": {
    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled
     * you need to have a permission with action: `org.users:read` with scope `users:*`.
     */
    get: operations["searchOrgUsers"];
  };
  "/orgs/{org_id}/users/{user_id}": {
    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled
     * you need to have a permission with action: `org.users:remove` with scope `users:*`.
     */
    delete: operations["removeOrgUser"];
    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled
     * you need to have a permission with action: `org.users.role:update` with scope `users:*`.
     */
    patch: operations["updateOrgUser"];
  };
  "/playlists": {
    get: operations["searchPlaylists"];
    post: operations["createPlaylist"];
  };
  "/playlists/{uid}": {
    get: operations["getPlaylist"];
    put: operations["updatePlaylist"];
    delete: operations["deletePlaylist"];
  };
  "/playlists/{uid}/items": {
    get: operations["getPlaylistItems"];
  };
  "/public/dashboards/{accessToken}": {
    /** Get public dashboard for view */
    get: operations["viewPublicDashboard"];
  };
  "/public/dashboards/{accessToken}/annotations": {
    /** Get annotations for a public dashboard */
    get: operations["getPublicAnnotations"];
  };
  "/public/dashboards/{accessToken}/panels/{panelId}/query": {
    /** Get results for a given panel on a public dashboard */
    post: operations["queryPublicDashboard"];
  };
  "/query-history": {
    /**
     * Returns a list of queries in the query history that matches the search criteria.
     * Query history search supports pagination. Use the `limit` parameter to control the maximum number of queries returned; the default limit is 100.
     * You can also use the `page` query parameter to fetch queries from any page other than the first one.
     */
    get: operations["searchQueries"];
    /** Adds new query to query history. */
    post: operations["createQuery"];
  };
  "/query-history/star/{query_history_uid}": {
    /** Adds star to query in query history as specified by the UID. */
    post: operations["starQuery"];
    /** Removes star from query in query history as specified by the UID. */
    delete: operations["unstarQuery"];
  };
  "/query-history/{query_history_uid}": {
    /** Deletes an existing query in query history as specified by the UID. This operation cannot be reverted. */
    delete: operations["deleteQuery"];
    /** Updates comment for query in query history as specified by the UID. */
    patch: operations["patchQueryComment"];
  };
  "/recording-rules": {
    get: operations["listRecordingRules"];
    put: operations["updateRecordingRule"];
    post: operations["createRecordingRule"];
  };
  "/recording-rules/test": {
    post: operations["testCreateRecordingRule"];
  };
  "/recording-rules/writer": {
    get: operations["getRecordingRuleWriteTarget"];
    /** It returns a 422 if there is not an existing prometheus data source configured. */
    post: operations["createRecordingRuleWriteTarget"];
    delete: operations["deleteRecordingRuleWriteTarget"];
  };
  "/recording-rules/{recordingRuleID}": {
    delete: operations["deleteRecordingRule"];
  };
  "/reports": {
    /**
     * Available to org admins only and with a valid or expired license.
     *
     * You need to have a permission with action `reports:read` with scope `reports:*`.
     */
    get: operations["getReports"];
    /**
     * Available to org admins only and with a valid license.
     *
     * You need to have a permission with action `reports.admin:create`.
     */
    post: operations["createReport"];
  };
  "/reports/email": {
    /**
     * Generate and send a report. This API waits for the report to be generated before returning. We recommend that you set the client’s timeout to at least 60 seconds. Available to org admins only and with a valid license.
     *
     * Only available in Grafana Enterprise v7.0+.
     * This API endpoint is experimental and may be deprecated in a future release. On deprecation, a migration strategy will be provided and the endpoint will remain functional until the next major release of Grafana.
     *
     * You need to have a permission with action `reports:send`.
     */
    post: operations["sendReport"];
  };
  "/reports/render/pdf/{dashboardID}": {
    /** Please refer to [reports enterprise](#/reports/renderReportPDFs) instead. This will be removed in Grafana 10. */
    get: operations["renderReportPDF"];
  };
  "/reports/render/pdfs": {
    /** Available to all users and with a valid license. */
    get: operations["renderReportPDFs"];
  };
  "/reports/settings": {
    /**
     * Available to org admins only and with a valid or expired license.
     *
     * You need to have a permission with action `reports.settings:read`x.
     */
    get: operations["getReportSettings"];
    /**
     * Available to org admins only and with a valid or expired license.
     *
     * You need to have a permission with action `reports.settings:write`xx.
     */
    post: operations["saveReportSettings"];
  };
  "/reports/test-email": {
    /**
     * Available to org admins only and with a valid license.
     *
     * You need to have a permission with action `reports:send`.
     */
    post: operations["sendTestEmail"];
  };
  "/reports/{id}": {
    /**
     * Available to org admins only and with a valid or expired license.
     *
     * You need to have a permission with action `reports:read` with scope `reports:id:<report ID>`.
     */
    get: operations["getReport"];
    /**
     * Available to org admins only and with a valid or expired license.
     *
     * You need to have a permission with action `reports.admin:write` with scope `reports:id:<report ID>`.
     */
    put: operations["updateReport"];
    /**
     * Available to org admins only and with a valid or expired license.
     *
     * You need to have a permission with action `reports.delete` with scope `reports:id:<report ID>`.
     */
    delete: operations["deleteReport"];
  };
  "/saml/acs": {
    post: operations["postACS"];
  };
  "/saml/metadata": {
    get: operations["getMetadata"];
  };
  "/saml/slo": {
    /**
     * There might be two possible requests:
     * 1. Logout response (callback) when Grafana initiates single logout and IdP returns response to logout request.
     * 2. Logout request when another SP initiates single logout and IdP sends logout request to the Grafana,
     * or in case of IdP-initiated logout.
     */
    get: operations["getSLO"];
    /**
     * There might be two possible requests:
     * 1. Logout response (callback) when Grafana initiates single logout and IdP returns response to logout request.
     * 2. Logout request when another SP initiates single logout and IdP sends logout request to the Grafana,
     * or in case of IdP-initiated logout.
     */
    post: operations["postSLO"];
  };
  "/search": {
    get: operations["search"];
    post: operations["SearchDevices"];
  };
  "/search/sorting": {
    get: operations["listSortOptions"];
  };
  "/serviceaccounts": {
    /**
     * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation):
     * action: `serviceaccounts:write` scope: `serviceaccounts:*`
     *
     * Requires basic authentication and that the authenticated user is a Grafana Admin.
     */
    post: operations["createServiceAccount"];
  };
  "/serviceaccounts/search": {
    /**
     * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation):
     * action: `serviceaccounts:read` scope: `serviceaccounts:*`
     */
    get: operations["searchOrgServiceAccountsWithPaging"];
  };
  "/serviceaccounts/{serviceAccountId}": {
    /**
     * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation):
     * action: `serviceaccounts:read` scope: `serviceaccounts:id:1` (single service account)
     */
    get: operations["retrieveServiceAccount"];
    /**
     * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation):
     * action: `serviceaccounts:delete` scope: `serviceaccounts:id:1` (single service account)
     */
    delete: operations["deleteServiceAccount"];
    /**
     * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation):
     * action: `serviceaccounts:write` scope: `serviceaccounts:id:1` (single service account)
     */
    patch: operations["updateServiceAccount"];
  };
  "/serviceaccounts/{serviceAccountId}/tokens": {
    /**
     * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation):
     * action: `serviceaccounts:read` scope: `global:serviceaccounts:id:1` (single service account)
     *
     * Requires basic authentication and that the authenticated user is a Grafana Admin.
     */
    get: operations["listTokens"];
    /**
     * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation):
     * action: `serviceaccounts:write` scope: `serviceaccounts:id:1` (single service account)
     */
    post: operations["createToken"];
  };
  "/serviceaccounts/{serviceAccountId}/tokens/{tokenId}": {
    /**
     * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation):
     * action: `serviceaccounts:write` scope: `serviceaccounts:id:1` (single service account)
     *
     * Requires basic authentication and that the authenticated user is a Grafana Admin.
     */
    delete: operations["deleteToken"];
  };
  "/signing-keys/keys": {
    /**
     * Required permissions
     * None
     */
    get: operations["retrieveJWKS"];
  };
  "/snapshot/shared-options": {
    get: operations["getSharingOptions"];
  };
  "/snapshots": {
    /** Snapshot public mode should be enabled or authentication is required. */
    post: operations["createDashboardSnapshot"];
  };
  "/snapshots-delete/{deleteKey}": {
    /** Snapshot public mode should be enabled or authentication is required. */
    get: operations["deleteDashboardSnapshotByDeleteKey"];
  };
  "/snapshots/{key}": {
    get: operations["getDashboardSnapshot"];
    delete: operations["deleteDashboardSnapshot"];
  };
  "/stats": {
    get: operations["listDevices"];
  };
  "/teams": {
    post: operations["createTeam"];
  };
  "/teams/search": {
    get: operations["searchTeams"];
  };
  "/teams/{teamId}/groups": {
    get: operations["getTeamGroupsApi"];
    post: operations["addTeamGroupApi"];
    delete: operations["removeTeamGroupApiQuery"];
  };
  "/teams/{team_id}": {
    get: operations["getTeamByID"];
    put: operations["updateTeam"];
    delete: operations["deleteTeamByID"];
  };
  "/teams/{team_id}/members": {
    get: operations["getTeamMembers"];
    post: operations["addTeamMember"];
  };
  "/teams/{team_id}/members/{user_id}": {
    put: operations["updateTeamMember"];
    delete: operations["removeTeamMember"];
  };
  "/teams/{team_id}/preferences": {
    get: operations["getTeamPreferences"];
    put: operations["updateTeamPreferences"];
  };
  "/user": {
    /** Get (current authenticated user) */
    get: operations["getSignedInUser"];
    put: operations["updateSignedInUser"];
  };
  "/user/auth-tokens": {
    /** Return a list of all auth tokens (devices) that the actual user currently have logged in from. */
    get: operations["getUserAuthTokens"];
  };
  "/user/email/update": {
    /** Update the email of user given a verification code. */
    get: operations["updateUserEmail"];
  };
  "/user/helpflags/clear": {
    get: operations["clearHelpFlags"];
  };
  "/user/helpflags/{flag_id}": {
    put: operations["setHelpFlag"];
  };
  "/user/orgs": {
    /** Return a list of all organizations of the current user. */
    get: operations["getSignedInUserOrgList"];
  };
  "/user/password": {
    /** Changes the password for the user. */
    put: operations["changeUserPassword"];
  };
  "/user/preferences": {
    get: operations["getUserPreferences"];
    /** Omitting a key (`theme`, `homeDashboardId`, `timezone`) will cause the current value to be replaced with the system default value. */
    put: operations["updateUserPreferences"];
    patch: operations["patchUserPreferences"];
  };
  "/user/quotas": {
    get: operations["getUserQuotas"];
  };
  "/user/revoke-auth-token": {
    /** Revokes the given auth token (device) for the actual user. User of issued auth token (device) will no longer be logged in and will be required to authenticate again upon next activity. */
    post: operations["revokeUserAuthToken"];
  };
  "/user/stars/dashboard/uid/{dashboard_uid}": {
    /** Stars the given Dashboard for the actual user. */
    post: operations["starDashboardByUID"];
    /** Deletes the starring of the given Dashboard for the actual user. */
    delete: operations["unstarDashboardByUID"];
  };
  "/user/stars/dashboard/{dashboard_id}": {
    /** Stars the given Dashboard for the actual user. */
    post: operations["starDashboard"];
    /** Deletes the starring of the given Dashboard for the actual user. */
    delete: operations["unstarDashboard"];
  };
  "/user/teams": {
    /** Return a list of all teams that the current user is member of. */
    get: operations["getSignedInUserTeamList"];
  };
  "/user/using/{org_id}": {
    /** Switch user context to the given organization. */
    post: operations["userSetUsingOrg"];
  };
  "/users": {
    /** Returns all users that the authenticated user has permission to view, admin permission required. */
    get: operations["searchUsers"];
  };
  "/users/lookup": {
    get: operations["getUserByLoginOrEmail"];
  };
  "/users/search": {
    get: operations["searchUsersWithPaging"];
  };
  "/users/{user_id}": {
    get: operations["getUserByID"];
    /** Update the user identified by id. */
    put: operations["updateUser"];
  };
  "/users/{user_id}/orgs": {
    /** Get organizations for user identified by id. */
    get: operations["getUserOrgList"];
  };
  "/users/{user_id}/teams": {
    /** Get teams for user identified by id. */
    get: operations["getUserTeams"];
  };
  "/v1/provisioning/alert-rules": {
    get: operations["RouteGetAlertRules"];
    post: operations["RoutePostAlertRule"];
  };
  "/v1/provisioning/alert-rules/export": {
    get: operations["RouteGetAlertRulesExport"];
  };
  "/v1/provisioning/alert-rules/{UID}": {
    get: operations["RouteGetAlertRule"];
    put: operations["RoutePutAlertRule"];
    delete: operations["RouteDeleteAlertRule"];
  };
  "/v1/provisioning/alert-rules/{UID}/export": {
    get: operations["RouteGetAlertRuleExport"];
  };
  "/v1/provisioning/contact-points": {
    get: operations["RouteGetContactpoints"];
    post: operations["RoutePostContactpoints"];
  };
  "/v1/provisioning/contact-points/export": {
    get: operations["RouteGetContactpointsExport"];
  };
  "/v1/provisioning/contact-points/{UID}": {
    put: operations["RoutePutContactpoint"];
    delete: operations["RouteDeleteContactpoints"];
  };
  "/v1/provisioning/folder/{FolderUID}/rule-groups/{Group}": {
    get: operations["RouteGetAlertRuleGroup"];
    put: operations["RoutePutAlertRuleGroup"];
  };
  "/v1/provisioning/folder/{FolderUID}/rule-groups/{Group}/export": {
    get: operations["RouteGetAlertRuleGroupExport"];
  };
  "/v1/provisioning/mute-timings": {
    get: operations["RouteGetMuteTimings"];
    post: operations["RoutePostMuteTiming"];
  };
  "/v1/provisioning/mute-timings/export": {
    get: operations["RouteExportMuteTimings"];
  };
  "/v1/provisioning/mute-timings/{name}": {
    get: operations["RouteGetMuteTiming"];
    put: operations["RoutePutMuteTiming"];
    delete: operations["RouteDeleteMuteTiming"];
  };
  "/v1/provisioning/mute-timings/{name}/export": {
    get: operations["RouteExportMuteTiming"];
  };
  "/v1/provisioning/policies": {
    get: operations["RouteGetPolicyTree"];
    put: operations["RoutePutPolicyTree"];
    delete: operations["RouteResetPolicyTree"];
  };
  "/v1/provisioning/policies/export": {
    get: operations["RouteGetPolicyTreeExport"];
  };
  "/v1/provisioning/templates": {
    get: operations["RouteGetTemplates"];
  };
  "/v1/provisioning/templates/{name}": {
    get: operations["RouteGetTemplate"];
    put: operations["RoutePutTemplate"];
    delete: operations["RouteDeleteTemplate"];
  };
  "/v1/sso-settings": {
    /** You need to have a permission with action `settings:read` with scope `settings:auth.<provider>:*`. */
    get: operations["listAllProvidersSettings"];
  };
  "/v1/sso-settings/{key}": {
    /** You need to have a permission with action `settings:read` with scope `settings:auth.<provider>:*`. */
    get: operations["getProviderSettings"];
    /**
     * Inserts or updates the SSO Settings for a provider.
     *
     * You need to have a permission with action `settings:write` and scope `settings:auth.<provider>:*`.
     */
    put: operations["updateProviderSettings"];
    /**
     * Removes the SSO Settings for a provider.
     *
     * You need to have a permission with action `settings:write` and scope `settings:auth.<provider>:*`.
     */
    delete: operations["removeProviderSettings"];
  };
}

export interface components {
  schemas: {
    Ack: { [key: string]: unknown };
    /** @description ActiveSyncStatusDTO holds the information for LDAP background Sync */
    ActiveSyncStatusDTO: {
      enabled?: boolean;
      /** Format: date-time */
      nextSync?: string;
      prevSync?: components["schemas"]["SyncResult"];
      schedule?: string;
    };
    ActiveUserStats: {
      /** Format: int64 */
      active_admins_and_editors?: number;
      /** Format: int64 */
      active_anonymous_devices?: number;
      /** Format: int64 */
      active_users?: number;
      /** Format: int64 */
      active_viewers?: number;
    };
    AddAPIKeyCommand: {
      name?: string;
      /** @enum {string} */
      role?: "None" | "Viewer" | "Editor" | "Admin";
      /** Format: int64 */
      secondsToLive?: number;
    };
    /** @description Also acts as api DTO */
    AddDataSourceCommand: {
      access?: components["schemas"]["DsAccess"];
      basicAuth?: boolean;
      basicAuthUser?: string;
      database?: string;
      isDefault?: boolean;
      jsonData?: components["schemas"]["Json"];
      name?: string;
      secureJsonData?: { [key: string]: string };
      type?: string;
      uid?: string;
      url?: string;
      user?: string;
      withCredentials?: boolean;
    };
    AddInviteForm: {
      loginOrEmail?: string;
      name?: string;
      /** @enum {string} */
      role?: "None" | "Viewer" | "Editor" | "Admin";
      sendEmail?: boolean;
    };
    AddOrgUserCommand: {
      loginOrEmail?: string;
      /** @enum {string} */
      role?: "None" | "Viewer" | "Editor" | "Admin";
    };
    AddServiceAccountTokenCommand: {
      name?: string;
      /** Format: int64 */
      secondsToLive?: number;
    };
    AddTeamMemberCommand: {
      /** Format: int64 */
      userId?: number;
    };
    AddTeamRoleCommand: {
      roleUid?: string;
    };
    AddUserRoleCommand: {
      global?: boolean;
      roleUid?: string;
    };
    Address: {
      address1?: string;
      address2?: string;
      city?: string;
      country?: string;
      state?: string;
      zipCode?: string;
    };
    AdminCreateUserForm: {
      email?: string;
      login?: string;
      name?: string;
      /** Format: int64 */
      orgId?: number;
      password?: components["schemas"]["Password"];
    };
    AdminCreateUserResponse: {
      /** Format: int64 */
      id?: number;
      message?: string;
    };
    AdminStats: {
      /** Format: int64 */
      activeAdmins?: number;
      /** Format: int64 */
      activeDevices?: number;
      /** Format: int64 */
      activeEditors?: number;
      /** Format: int64 */
      activeSessions?: number;
      /** Format: int64 */
      activeUsers?: number;
      /** Format: int64 */
      activeViewers?: number;
      /** Format: int64 */
      admins?: number;
      /** Format: int64 */
      alerts?: number;
      /** Format: int64 */
      dailyActiveAdmins?: number;
      /** Format: int64 */
      dailyActiveEditors?: number;
      /** Format: int64 */
      dailyActiveSessions?: number;
      /** Format: int64 */
      dailyActiveUsers?: number;
      /** Format: int64 */
      dailyActiveViewers?: number;
      /** Format: int64 */
      dashboards?: number;
      /** Format: int64 */
      datasources?: number;
      /** Format: int64 */
      editors?: number;
      /** Format: int64 */
      monthlyActiveUsers?: number;
      /** Format: int64 */
      orgs?: number;
      /** Format: int64 */
      playlists?: number;
      /** Format: int64 */
      snapshots?: number;
      /** Format: int64 */
      stars?: number;
      /** Format: int64 */
      tags?: number;
      /** Format: int64 */
      users?: number;
      /** Format: int64 */
      viewers?: number;
    };
    AdminUpdateUserPasswordForm: {
      password?: components["schemas"]["Password"];
    };
    AdminUpdateUserPermissionsForm: {
      isGrafanaAdmin?: boolean;
    };
    /** Alert has info for an alert. */
    Alert: {
      /** Format: date-time */
      activeAt?: string;
      annotations: components["schemas"]["overrideLabels"];
      labels: components["schemas"]["overrideLabels"];
      state: string;
      value: string;
    };
    /** AlertDiscovery has info for all active alerts. */
    AlertDiscovery: {
      alerts: components["schemas"]["Alert"][];
    };
    AlertInstancesResponse: {
      /**
       * @description Instances is an array of arrow encoded dataframes
       * each frame has a single row, and a column for each instance (alert identified by unique labels) with a boolean value (firing/not firing)
       */
      instances?: number[][];
    };
    AlertListItemDTO: {
      /** Format: int64 */
      dashboardId?: number;
      dashboardSlug?: string;
      dashboardUid?: string;
      evalData?: components["schemas"]["Json"];
      /** Format: date-time */
      evalDate?: string;
      executionError?: string;
      /** Format: int64 */
      id?: number;
      name?: string;
      /** Format: date-time */
      newStateDate?: string;
      /** Format: int64 */
      panelId?: number;
      state?: components["schemas"]["AlertStateType"];
      url?: string;
    };
    /** AlertManager models a configured Alert Manager. */
    AlertManager: {
      url?: string;
    };
    AlertManagerNotReady: { [key: string]: unknown };
    /** AlertManagersResult contains the result from querying the alertmanagers endpoint. */
    AlertManagersResult: {
      activeAlertManagers?: components["schemas"]["AlertManager"][];
      droppedAlertManagers?: components["schemas"]["AlertManager"][];
    };
    AlertNotification: {
      /** Format: date-time */
      created?: string;
      disableResolveMessage?: boolean;
      frequency?: string;
      /** Format: int64 */
      id?: number;
      isDefault?: boolean;
      name?: string;
      secureFields?: { [key: string]: boolean };
      sendReminder?: boolean;
      settings?: components["schemas"]["Json"];
      type?: string;
      uid?: string;
      /** Format: date-time */
      updated?: string;
    };
    AlertNotificationLookup: {
      /** Format: int64 */
      id?: number;
      isDefault?: boolean;
      name?: string;
      type?: string;
      uid?: string;
    };
    AlertPair: {
      alertRule?: components["schemas"]["AlertRuleUpgrade"];
      error?: string;
      legacyAlert?: components["schemas"]["LegacyAlert"];
    };
    /** AlertQuery represents a single query associated with an alert definition. */
    AlertQuery: {
      /** @description Grafana data source unique identifier; it should be '__expr__' for a Server Side Expression operation. */
      datasourceUid?: string;
      /** @description JSON is the raw JSON query and includes the above properties as well as custom properties. */
      model?: { [key: string]: unknown };
      /**
       * @description QueryType is an optional identifier for the type of query.
       * It can be used to distinguish different types of queries.
       */
      queryType?: string;
      /** @description RefID is the unique identifier of the query, set by the frontend call. */
      refId?: string;
      relativeTimeRange?: components["schemas"]["RelativeTimeRange"];
    };
    /** AlertQueryExport is the provisioned export of models.AlertQuery. */
    AlertQueryExport: {
      datasourceUid?: string;
      model?: { [key: string]: unknown };
      queryType?: string;
      refId?: string;
      relativeTimeRange?: components["schemas"]["RelativeTimeRangeExport"];
    };
    AlertResponse: {
      data?: components["schemas"]["AlertDiscovery"];
      error?: string;
      errorType?: components["schemas"]["ErrorType"];
      status: string;
    };
    /** AlertRuleExport is the provisioned file export of models.AlertRule. */
    AlertRuleExport: {
      annotations?: { [key: string]: string };
      condition?: string;
      dasboardUid?: string;
      data?: components["schemas"]["AlertQueryExport"][];
      /** @enum {string} */
      execErrState?: "OK" | "Alerting" | "Error";
      for?: components["schemas"]["Duration"];
      isPaused?: boolean;
      labels?: { [key: string]: string };
      /** @enum {string} */
      noDataState?: "Alerting" | "NoData" | "OK";
      /** Format: int64 */
      panelId?: number;
      title?: string;
      uid?: string;
    };
    AlertRuleGroup: {
      folderUid?: string;
      /** Format: int64 */
      interval?: number;
      rules?: components["schemas"]["ProvisionedAlertRule"][];
      title?: string;
    };
    /** AlertRuleGroupExport is the provisioned file export of AlertRuleGroupV1. */
    AlertRuleGroupExport: {
      folder?: string;
      interval?: components["schemas"]["Duration"];
      name?: string;
      /** Format: int64 */
      orgId?: number;
      rules?: components["schemas"]["AlertRuleExport"][];
    };
    AlertRuleGroupMetadata: {
      /** Format: int64 */
      interval?: number;
    };
    AlertRuleUpgrade: {
      sendsTo?: string[];
      title?: string;
      uid?: string;
    };
    AlertStateInfoDTO: {
      /** Format: int64 */
      dashboardId?: number;
      /** Format: int64 */
      id?: number;
      /** Format: date-time */
      newStateDate?: string;
      /** Format: int64 */
      panelId?: number;
      state?: components["schemas"]["AlertStateType"];
    };
    AlertStateType: string;
    AlertTestCommand: {
      dashboard?: components["schemas"]["Json"];
      /** Format: int64 */
      panelId?: number;
    };
    AlertTestResult: {
      conditionEvals?: string;
      error?: string;
      firing?: boolean;
      logs?: components["schemas"]["AlertTestResultLog"][];
      matches?: components["schemas"]["EvalMatch"][];
      state?: components["schemas"]["AlertStateType"];
      timeMs?: string;
    };
    AlertTestResultLog: {
      data?: unknown;
      message?: string;
    };
    /** AlertingFileExport is the full provisioned file export. */
    AlertingFileExport: {
      /** Format: int64 */
      apiVersion?: number;
      contactPoints?: components["schemas"]["ContactPointExport"][];
      groups?: components["schemas"]["AlertRuleGroupExport"][];
      muteTimes?: components["schemas"]["MuteTimeIntervalExport"][];
      policies?: components["schemas"]["NotificationPolicyExport"][];
    };
    /** @description adapted from cortex */
    AlertingRule: {
      /** Format: date-time */
      activeAt: string;
      alerts?: components["schemas"]["Alert"][];
      annotations: components["schemas"]["overrideLabels"];
      /** Format: double */
      duration?: number;
      /** Format: double */
      evaluationTime?: number;
      health: string;
      labels?: components["schemas"]["overrideLabels"];
      lastError?: string;
      /** Format: date-time */
      lastEvaluation?: string;
      name: string;
      query: string;
      /** @description State can be "pending", "firing", "inactive". */
      state: string;
      totals?: { [key: string]: number };
      totalsFiltered?: { [key: string]: number };
      type: components["schemas"]["RuleType"];
    };
    AlertingStatus: {
      /** @enum {string} */
      alertmanagersChoice?: "all" | "internal" | "external";
      /** Format: int64 */
      numExternalAlertmanagers?: number;
    };
    Annotation: {
      /** Format: int64 */
      alertId?: number;
      alertName?: string;
      avatarUrl?: string;
      /** Format: int64 */
      created?: number;
      /** Format: int64 */
      dashboardId?: number;
      dashboardUID?: string;
      data?: components["schemas"]["Json"];
      email?: string;
      /** Format: int64 */
      id?: number;
      login?: string;
      newState?: string;
      /** Format: int64 */
      panelId?: number;
      prevState?: string;
      tags?: string[];
      text?: string;
      /** Format: int64 */
      time?: number;
      /** Format: int64 */
      timeEnd?: number;
      /** Format: int64 */
      updated?: number;
      /** Format: int64 */
      userId?: number;
    };
    AnnotationActions: {
      canAdd?: boolean;
      canDelete?: boolean;
      canEdit?: boolean;
    };
    AnnotationEvent: {
      color?: string;
      /** Format: int64 */
      dashboardId?: number;
      /** Format: int64 */
      id?: number;
      isRegion?: boolean;
      /** Format: int64 */
      panelId?: number;
      source?: components["schemas"]["AnnotationQuery"];
      tags?: string[];
      text?: string;
      /** Format: int64 */
      time?: number;
      /** Format: int64 */
      timeEnd?: number;
    };
    /** AnnotationPanelFilter defines model for AnnotationPanelFilter. */
    AnnotationPanelFilter: {
      /** @description Should the specified panels be included or excluded */
      exclude?: boolean;
      /** @description Panel IDs that should be included or excluded */
      ids?: number[];
    };
    AnnotationPermission: {
      dashboard?: components["schemas"]["AnnotationActions"];
      organization?: components["schemas"]["AnnotationActions"];
    };
    /**
     * @description TODO docs
     * FROM: AnnotationQuery in grafana-data/src/types/annotations.ts
     */
    AnnotationQuery: {
      /**
       * Format: float
       * @description Set to 1 for the standard annotation query all dashboards have by default.
       */
      builtIn?: number;
      datasource?: components["schemas"]["DataSourceRef"];
      /** @description When enabled the annotation query is issued with every dashboard refresh */
      enable?: boolean;
      filter?: components["schemas"]["AnnotationPanelFilter"];
      /**
       * @description Annotation queries can be toggled on or off at the top of the dashboard.
       * When hide is true, the toggle is not shown in the dashboard.
       */
      hide?: boolean;
      /** @description Color to use for the annotation event markers */
      iconColor?: string;
      /** @description Name of annotation. */
      name?: string;
      target?: components["schemas"]["AnnotationTarget"];
      /** @description TODO -- this should not exist here, it is based on the --grafana-- datasource */
      type?: string;
    };
    /**
     * @description TODO: this should be a regular DataQuery that depends on the selected dashboard
     * these match the properties of the "grafana" datasouce that is default in most dashboards
     */
    AnnotationTarget: {
      /**
       * Format: int64
       * @description Only required/valid for the grafana datasource...
       * but code+tests is already depending on it so hard to change
       */
      limit?: number;
      /**
       * @description Only required/valid for the grafana datasource...
       * but code+tests is already depending on it so hard to change
       */
      matchAny?: boolean;
      /**
       * @description Only required/valid for the grafana datasource...
       * but code+tests is already depending on it so hard to change
       */
      tags?: string[];
      /**
       * @description Only required/valid for the grafana datasource...
       * but code+tests is already depending on it so hard to change
       */
      type?: string;
    };
    ApiKeyDTO: {
      accessControl?: components["schemas"]["Metadata"];
      /** Format: date-time */
      expiration?: string;
      /** Format: int64 */
      id?: number;
      /** Format: date-time */
      lastUsedAt?: string;
      name?: string;
      /** @enum {string} */
      role?: "None" | "Viewer" | "Editor" | "Admin";
    };
    ApiRuleNode: {
      alert?: string;
      annotations?: { [key: string]: string };
      expr?: string;
      for?: string;
      keep_firing_for?: string;
      labels?: { [key: string]: string };
      record?: string;
    };
    Assignments: {
      builtInRoles?: boolean;
      serviceAccounts?: boolean;
      teams?: boolean;
      users?: boolean;
    };
    /**
     * @description AttributeTypeAndValue mirrors the ASN.1 structure of the same name in
     * RFC 5280, Section 4.1.2.4.
     */
    AttributeTypeAndValue: {
      Type?: components["schemas"]["ObjectIdentifier"];
      Value?: unknown;
    };
    /** Authorization contains HTTP authorization credentials. */
    Authorization: {
      credentials?: components["schemas"]["Secret"];
      credentials_file?: string;
      type?: string;
    };
    BacktestConfig: {
      annotations?: { [key: string]: string };
      condition?: string;
      data?: components["schemas"]["AlertQuery"][];
      for?: components["schemas"]["Duration"];
      /** Format: date-time */
      from?: string;
      interval?: components["schemas"]["Duration"];
      labels?: { [key: string]: string };
      /** @enum {string} */
      no_data_state?: "Alerting" | "NoData" | "OK";
      title?: string;
      /** Format: date-time */
      to?: string;
    };
    BacktestResult: components["schemas"]["Frame"];
    /** BasicAuth contains basic HTTP authentication credentials. */
    BasicAuth: {
      password?: components["schemas"]["Secret"];
      password_file?: string;
      username?: string;
      username_file?: string;
    };
    CalculateDiffTarget: {
      /** Format: int64 */
      dashboardId?: number;
      unsavedDashboard?: components["schemas"]["Json"];
      /** Format: int64 */
      version?: number;
    };
    /** A Certificate represents an X.509 certificate. */
    Certificate: {
      AuthorityKeyId?: number[];
      /**
       * @description BasicConstraintsValid indicates whether IsCA, MaxPathLen,
       * and MaxPathLenZero are valid.
       */
      BasicConstraintsValid?: boolean;
      /** @description CRL Distribution Points */
      CRLDistributionPoints?: string[];
      /**
       * @description Subject Alternate Name values. (Note that these values may not be valid
       * if invalid values were contained within a parsed certificate. For
       * example, an element of DNSNames may not be a valid DNS domain name.)
       */
      DNSNames?: string[];
      EmailAddresses?: string[];
      ExcludedDNSDomains?: string[];
      ExcludedEmailAddresses?: string[];
      ExcludedIPRanges?: components["schemas"]["IPNet"][];
      ExcludedURIDomains?: string[];
      ExtKeyUsage?: components["schemas"]["ExtKeyUsage"][];
      /**
       * @description Extensions contains raw X.509 extensions. When parsing certificates,
       * this can be used to extract non-critical extensions that are not
       * parsed by this package. When marshaling certificates, the Extensions
       * field is ignored, see ExtraExtensions.
       */
      Extensions?: components["schemas"]["Extension"][];
      /**
       * @description ExtraExtensions contains extensions to be copied, raw, into any
       * marshaled certificates. Values override any extensions that would
       * otherwise be produced based on the other fields. The ExtraExtensions
       * field is not populated when parsing certificates, see Extensions.
       */
      ExtraExtensions?: components["schemas"]["Extension"][];
      IPAddresses?: string[];
      IsCA?: boolean;
      Issuer?: components["schemas"]["Name"];
      IssuingCertificateURL?: string[];
      KeyUsage?: components["schemas"]["KeyUsage"];
      /**
       * Format: int64
       * @description MaxPathLen and MaxPathLenZero indicate the presence and
       * value of the BasicConstraints' "pathLenConstraint".
       *
       * When parsing a certificate, a positive non-zero MaxPathLen
       * means that the field was specified, -1 means it was unset,
       * and MaxPathLenZero being true mean that the field was
       * explicitly set to zero. The case of MaxPathLen==0 with MaxPathLenZero==false
       * should be treated equivalent to -1 (unset).
       *
       * When generating a certificate, an unset pathLenConstraint
       * can be requested with either MaxPathLen == -1 or using the
       * zero value for both MaxPathLen and MaxPathLenZero.
       */
      MaxPathLen?: number;
      /**
       * @description MaxPathLenZero indicates that BasicConstraintsValid==true
       * and MaxPathLen==0 should be interpreted as an actual
       * maximum path length of zero. Otherwise, that combination is
       * interpreted as MaxPathLen not being set.
       */
      MaxPathLenZero?: boolean;
      /** Format: date-time */
      NotBefore?: string;
      /** @description RFC 5280, 4.2.2.1 (Authority Information Access) */
      OCSPServer?: string[];
      PermittedDNSDomains?: string[];
      /** @description Name constraints */
      PermittedDNSDomainsCritical?: boolean;
      PermittedEmailAddresses?: string[];
      PermittedIPRanges?: components["schemas"]["IPNet"][];
      PermittedURIDomains?: string[];
      PolicyIdentifiers?: components["schemas"]["ObjectIdentifier"][];
      PublicKey?: unknown;
      PublicKeyAlgorithm?: components["schemas"]["PublicKeyAlgorithm"];
      Raw?: number[];
      RawIssuer?: number[];
      RawSubject?: number[];
      RawSubjectPublicKeyInfo?: number[];
      RawTBSCertificate?: number[];
      SerialNumber?: string;
      Signature?: number[];
      SignatureAlgorithm?: components["schemas"]["SignatureAlgorithm"];
      Subject?: components["schemas"]["Name"];
      SubjectKeyId?: number[];
      URIs?: components["schemas"]["URL"][];
      /**
       * @description UnhandledCriticalExtensions contains a list of extension IDs that
       * were not (fully) processed when parsing. Verify will fail if this
       * slice is non-empty, unless verification is delegated to an OS
       * library which understands all the critical extensions.
       *
       * Users can access these extensions using Extensions and can remove
       * elements from this slice if they believe that they have been
       * handled.
       */
      UnhandledCriticalExtensions?: components["schemas"]["ObjectIdentifier"][];
      UnknownExtKeyUsage?: components["schemas"]["ObjectIdentifier"][];
      /** Format: int64 */
      Version?: number;
    };
    ChangeUserPasswordCommand: {
      newPassword?: components["schemas"]["Password"];
      oldPassword?: components["schemas"]["Password"];
    };
    /**
     * Format: double
     * @description ConfFloat64 is a float64. It Marshals float64 values of NaN of Inf
     * to null.
     */
    ConfFloat64: number;
    /** Config is the top-level configuration for Alertmanager's config files. */
    Config: {
      global?: components["schemas"]["GlobalConfig"];
      inhibit_rules?: components["schemas"]["InhibitRule"][];
      mute_time_intervals?: components["schemas"]["MuteTimeInterval"][];
      route?: components["schemas"]["Route"];
      templates?: string[];
    };
    ContactPair: {
      contactPoint?: components["schemas"]["ContactPointUpgrade"];
      error?: string;
      legacyChannel?: components["schemas"]["LegacyChannel"];
    };
    /** ContactPointExport is the provisioned file export of alerting.ContactPointV1. */
    ContactPointExport: {
      name?: string;
      /** Format: int64 */
      orgId?: number;
      receivers?: components["schemas"]["ReceiverExport"][];
    };
    ContactPointUpgrade: {
      name?: string;
      routeMatchers?: components["schemas"]["ObjectMatchers"];
      type?: string;
    };
    ContactPoints: components["schemas"]["EmbeddedContactPoint"][];
    /** CookiePreferences defines model for CookiePreferences. */
    CookiePreferences: {
      analytics?: { [key: string]: unknown };
      functional?: { [key: string]: unknown };
      performance?: { [key: string]: unknown };
    };
    CookieType: string;
    /** @description Correlation is the model for correlations definitions */
    Correlation: {
      config?: components["schemas"]["CorrelationConfig"];
      /**
       * @description Description of the correlation
       * @example Logs to Traces
       */
      description?: string;
      /**
       * @description Label identifying the correlation
       * @example My Label
       */
      label?: string;
      /**
       * Format: int64
       * @description OrgID of the data source the correlation originates from
       * @example 1
       */
      orgId?: number;
      /** @description Provisioned True if the correlation was created during provisioning */
      provisioned?: boolean;
      /**
       * @description UID of the data source the correlation originates from
       * @example d0oxYRg4z
       */
      sourceUID?: string;
      /**
       * @description UID of the data source the correlation points to
       * @example PE1C5CBDA0504A6A3
       */
      targetUID?: string;
      /**
       * @description Unique identifier of the correlation
       * @example 50xhMlg9k
       */
      uid?: string;
    };
    CorrelationConfig: {
      /**
       * @description Field used to attach the correlation link
       * @example message
       */
      field: string;
      /**
       * @description Target data query
       * @example {
       *   "prop1": "value1",
       *   "prop2": "value"
       * }
       */
      target: { [key: string]: unknown };
      transformations?: components["schemas"]["Transformations"];
      type: components["schemas"]["CorrelationConfigType"];
    };
    CorrelationConfigType: string;
    CorrelationConfigUpdateDTO: {
      /**
       * @description Field used to attach the correlation link
       * @example message
       */
      field?: string;
      /**
       * @description Target data query
       * @example {
       *   "prop1": "value1",
       *   "prop2": "value"
       * }
       */
      target?: { [key: string]: unknown };
      /**
       * @description Source data transformations
       * @example [
       *   {
       *     "type": "logfmt"
       *   },
       *   {
       *     "expression": "(Superman|Batman)",
       *     "type": "regex",
       *     "variable": "name"
       *   }
       * ]
       */
      transformations?: components["schemas"]["Transformation"][];
      type?: components["schemas"]["CorrelationConfigType"];
    };
    /**
     * CounterResetHint contains the known information about a counter reset,
     * Format: uint8
     * @description or alternatively that we are dealing with a gauge histogram, where counter resets do not apply.
     */
    CounterResetHint: number;
    CreateAlertNotificationCommand: {
      disableResolveMessage?: boolean;
      frequency?: string;
      isDefault?: boolean;
      name?: string;
      secureSettings?: { [key: string]: string };
      sendReminder?: boolean;
      settings?: components["schemas"]["Json"];
      type?: string;
      uid?: string;
    };
    /** @description CreateCorrelationCommand is the command for creating a correlation */
    CreateCorrelationCommand: {
      config?: components["schemas"]["CorrelationConfig"];
      /**
       * @description Optional description of the correlation
       * @example Logs to Traces
       */
      description?: string;
      /**
       * @description Optional label identifying the correlation
       * @example My label
       */
      label?: string;
      /** @description True if correlation was created with provisioning. This makes it read-only. */
      provisioned?: boolean;
      /**
       * @description Target data source UID to which the correlation is created. required if config.type = query
       * @example PE1C5CBDA0504A6A3
       */
      targetUID?: string;
    };
    /** @description CreateCorrelationResponse is the response struct for CreateCorrelationCommand */
    CreateCorrelationResponseBody: {
      /** @example Correlation created */
      message?: string;
      result?: components["schemas"]["Correlation"];
    };
    CreateDashboardSnapshotCommand: {
      /**
       * @description APIVersion defines the versioned schema of this representation of an object.
       * Servers should convert recognized schemas to the latest internal value, and
       * may reject unrecognized values.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
       * +optional
       */
      apiVersion?: string;
      dashboard: components["schemas"]["Unstructured"];
      /** @description Unique key used to delete the snapshot. It is different from the `key` so that only the creator can delete the snapshot. Required if `external` is `true`. */
      deleteKey?: string;
      /**
       * Format: int64
       * @description When the snapshot should expire in seconds in seconds. Default is never to expire.
       * @default 0
       */
      expires?: number;
      /**
       * @description these are passed when storing an external snapshot ref
       * Save the snapshot on an external server rather than locally.
       * @default false
       */
      external?: boolean;
      /** @description Define the unique key. Required if `external` is `true`. */
      key?: string;
      /**
       * @description Kind is a string value representing the REST resource this object represents.
       * Servers may infer this from the endpoint the client submits requests to.
       * Cannot be updated.
       * In CamelCase.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       */
      kind?: string;
      /** @description Snapshot name */
      name?: string;
    };
    /**
     * @description CreateFolderCommand captures the information required by the folder service
     * to create a folder.
     */
    CreateFolderCommand: {
      description?: string;
      parentUid?: string;
      title?: string;
      uid?: string;
    };
    /** @description CreateLibraryElementCommand is the command for adding a LibraryElement */
    CreateLibraryElementCommand: {
      /**
       * Format: int64
       * @description ID of the folder where the library element is stored.
       *
       * Deprecated: use FolderUID instead
       */
      folderId?: number;
      /** @description UID of the folder where the library element is stored. */
      folderUid?: string;
      /**
       * Format: int64
       * @description Kind of element to create, Use 1 for library panels or 2 for c.
       * Description:
       * 1 - library panels
       * 2 - library variables
       * @enum {integer}
       */
      kind?: 1 | 2;
      /** @description The JSON model for the library element. */
      model?: { [key: string]: unknown };
      /** @description Name of the library element. */
      name?: string;
      uid?: string;
    };
    CreateOrUpdateReportConfig: {
      /** Format: int64 */
      dashboardId?: number;
      dashboardUid?: string;
      dashboards?: components["schemas"]["ReportDashboard"][];
      enableCsv?: boolean;
      enableDashboardUrl?: boolean;
      formats?: components["schemas"]["Type"][];
      message?: string;
      name?: string;
      options?: components["schemas"]["ReportOptions"];
      recipients?: string;
      replyTo?: string;
      /** Format: int64 */
      scaleFactor?: number;
      schedule?: components["schemas"]["ReportSchedule"];
      state?: components["schemas"]["State"];
      templateVars?: { [key: string]: unknown };
    };
    CreateOrgCommand: {
      name?: string;
    };
    CreatePlaylistCommand: {
      interval?: string;
      items?: components["schemas"]["PlaylistItem"][];
      name?: string;
    };
    /** @description CreateQueryInQueryHistoryCommand is the command for adding query history */
    CreateQueryInQueryHistoryCommand: {
      /**
       * @description UID of the data source for which are queries stored.
       * @example PE1C5CBDA0504A6A3
       */
      datasourceUid?: string;
      queries: components["schemas"]["Json"];
    };
    CreateRoleForm: {
      description?: string;
      displayName?: string;
      global?: boolean;
      group?: string;
      hidden?: boolean;
      name?: string;
      permissions?: components["schemas"]["Permission"][];
      uid?: string;
      /** Format: int64 */
      version?: number;
    };
    CreateServiceAccountForm: {
      /** @example false */
      isDisabled?: boolean;
      /** @example grafana */
      name?: string;
      /**
       * @example Admin
       * @enum {string}
       */
      role?: "None" | "Viewer" | "Editor" | "Admin";
    };
    CreateTeamCommand: {
      email?: string;
      name?: string;
    };
    DashboardACLInfoDTO: {
      /** Format: date-time */
      created?: string;
      /** Format: int64 */
      dashboardId?: number;
      /**
       * Format: int64
       * @description Deprecated: use FolderUID instead
       */
      folderId?: number;
      folderUid?: string;
      inherited?: boolean;
      isFolder?: boolean;
      permission?: components["schemas"]["PermissionType"];
      permissionName?: string;
      /** @enum {string} */
      role?: "None" | "Viewer" | "Editor" | "Admin";
      slug?: string;
      team?: string;
      teamAvatarUrl?: string;
      teamEmail?: string;
      /** Format: int64 */
      teamId?: number;
      title?: string;
      uid?: string;
      /** Format: date-time */
      updated?: string;
      url?: string;
      userAvatarUrl?: string;
      userEmail?: string;
      /** Format: int64 */
      userId?: number;
      userLogin?: string;
    };
    DashboardACLUpdateItem: {
      permission?: components["schemas"]["PermissionType"];
      /** @enum {string} */
      role?: "None" | "Viewer" | "Editor" | "Admin";
      /** Format: int64 */
      teamId?: number;
      /** Format: int64 */
      userId?: number;
    };
    /**
     * @description These are the values expected to be sent from an end user
     * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
     */
    DashboardCreateCommand: {
      /**
       * @description APIVersion defines the versioned schema of this representation of an object.
       * Servers should convert recognized schemas to the latest internal value, and
       * may reject unrecognized values.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
       * +optional
       */
      apiVersion?: string;
      dashboard: components["schemas"]["Unstructured"];
      /**
       * Format: int64
       * @description When the snapshot should expire in seconds in seconds. Default is never to expire.
       * @default 0
       */
      expires?: number;
      /**
       * @description these are passed when storing an external snapshot ref
       * Save the snapshot on an external server rather than locally.
       * @default false
       */
      external?: boolean;
      /**
       * @description Kind is a string value representing the REST resource this object represents.
       * Servers may infer this from the endpoint the client submits requests to.
       * Cannot be updated.
       * In CamelCase.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       */
      kind?: string;
      /** @description Snapshot name */
      name?: string;
    };
    DashboardFullWithMeta: {
      dashboard?: components["schemas"]["Json"];
      meta?: components["schemas"]["DashboardMeta"];
    };
    DashboardMeta: {
      annotationsPermissions?: components["schemas"]["AnnotationPermission"];
      canAdmin?: boolean;
      canDelete?: boolean;
      canEdit?: boolean;
      canSave?: boolean;
      canStar?: boolean;
      /** Format: date-time */
      created?: string;
      createdBy?: string;
      /** Format: date-time */
      expires?: string;
      /**
       * Format: int64
       * @description Deprecated: use FolderUID instead
       */
      folderId?: number;
      folderTitle?: string;
      folderUid?: string;
      folderUrl?: string;
      hasAcl?: boolean;
      isFolder?: boolean;
      isSnapshot?: boolean;
      isStarred?: boolean;
      provisioned?: boolean;
      provisionedExternalId?: string;
      publicDashboardEnabled?: boolean;
      publicDashboardUid?: string;
      slug?: string;
      type?: string;
      /** Format: date-time */
      updated?: string;
      updatedBy?: string;
      url?: string;
      /** Format: int64 */
      version?: number;
    };
    DashboardRedirect: {
      redirectUri?: string;
    };
    /** @description DashboardSnapshotDTO without dashboard map */
    DashboardSnapshotDTO: {
      /** Format: date-time */
      created?: string;
      /** Format: date-time */
      expires?: string;
      external?: boolean;
      externalUrl?: string;
      key?: string;
      name?: string;
      /** Format: date-time */
      updated?: string;
    };
    DashboardTagCloudItem: {
      /** Format: int64 */
      count?: number;
      term?: string;
    };
    DashboardUpgrade: {
      /** Format: int64 */
      dashboardId?: number;
      dashboardName?: string;
      dashboardUid?: string;
      error?: string;
      folderName?: string;
      folderUid?: string;
      migratedAlerts?: components["schemas"]["AlertPair"][];
      newFolderName?: string;
      newFolderUid?: string;
      provisioned?: boolean;
      warning?: string;
    };
    /**
     * @description DashboardVersionMeta extends the DashboardVersionDTO with the names
     * associated with the UserIds, overriding the field with the same name from
     * the DashboardVersionDTO model.
     */
    DashboardVersionMeta: {
      /** Format: date-time */
      created?: string;
      createdBy?: string;
      /** Format: int64 */
      dashboardId?: number;
      data?: components["schemas"]["Json"];
      /** Format: int64 */
      id?: number;
      message?: string;
      /** Format: int64 */
      parentVersion?: number;
      /** Format: int64 */
      restoredFrom?: number;
      uid?: string;
      /** Format: int64 */
      version?: number;
    };
    /** @description DataLink define what */
    DataLink: {
      internal?: components["schemas"]["InternalDataLink"];
      targetBlank?: boolean;
      title?: string;
      url?: string;
    };
    /**
     * DataResponse contains the results from a DataQuery.
     * @description A map of RefIDs (unique query identifiers) to this type makes up the Responses property of a QueryDataResponse.
     * The Error property is used to allow for partial success responses from the containing QueryDataResponse.
     */
    DataResponse: {
      /** @description Error is a property to be set if the corresponding DataQuery has an error. */
      Error?: string;
      ErrorSource?: components["schemas"]["ErrorSource"];
      Frames?: components["schemas"]["Frames"];
      Status?: components["schemas"]["Status"];
    };
    DataSource: {
      access?: components["schemas"]["DsAccess"];
      accessControl?: components["schemas"]["Metadata"];
      basicAuth?: boolean;
      basicAuthUser?: string;
      database?: string;
      /** Format: int64 */
      id?: number;
      isDefault?: boolean;
      jsonData?: components["schemas"]["Json"];
      name?: string;
      /** Format: int64 */
      orgId?: number;
      readOnly?: boolean;
      secureJsonFields?: { [key: string]: boolean };
      type?: string;
      typeLogoUrl?: string;
      uid?: string;
      url?: string;
      user?: string;
      /** Format: int64 */
      version?: number;
      withCredentials?: boolean;
    };
    DataSourceList: components["schemas"]["DataSourceListItemDTO"][];
    DataSourceListItemDTO: {
      access?: components["schemas"]["DsAccess"];
      basicAuth?: boolean;
      database?: string;
      /** Format: int64 */
      id?: number;
      isDefault?: boolean;
      jsonData?: components["schemas"]["Json"];
      name?: string;
      /** Format: int64 */
      orgId?: number;
      readOnly?: boolean;
      type?: string;
      typeLogoUrl?: string;
      typeName?: string;
      uid?: string;
      url?: string;
      user?: string;
    };
    /** @description Ref to a DataSource instance */
    DataSourceRef: {
      /** @description The plugin type-id */
      type?: string;
      /** @description Specific datasource instance */
      uid?: string;
    };
    /**
     * DataTopic is used to identify which topic the frame should be assigned to.
     * @description nolint:revive
     */
    DataTopic: string;
    DeleteCorrelationResponseBody: {
      /** @example Correlation deleted */
      message?: string;
    };
    DeleteTokenCommand: {
      instance?: string;
    };
    DescendantCounts: { [key: string]: number };
    Description: {
      assignments?: components["schemas"]["Assignments"];
      permissions?: string[];
    };
    DeviceSearchHitDTO: {
      clientIp?: string;
      /** Format: date-time */
      createdAt?: string;
      deviceId?: string;
      /** Format: date-time */
      lastSeenAt?: string;
      /** Format: date-time */
      updatedAt?: string;
      userAgent?: string;
    };
    /** DiscordConfig configures notifications via Discord. */
    DiscordConfig: {
      http_config?: components["schemas"]["HTTPClientConfig"];
      message?: string;
      send_resolved?: boolean;
      title?: string;
      webhook_url?: components["schemas"]["SecretURL"];
    };
    DiscoveryBase: {
      error?: string;
      errorType?: components["schemas"]["ErrorType"];
      status: string;
    };
    DsAccess: string;
    /**
     * Format: int64
     * @description Datasource permission
     * Description:
     * `0` - No Access
     * `1` - Query
     * `2` - Edit
     * Enum: 0,1,2
     */
    DsPermissionType: number;
    /**
     * Format: int64
     * @description A Duration represents the elapsed time between two instants
     * as an int64 nanosecond count. The representation limits the
     * largest representable duration to approximately 290 years.
     */
    Duration: number;
    /** EmailConfig configures notifications via mail. */
    EmailConfig: {
      auth_identity?: string;
      auth_password?: components["schemas"]["Secret"];
      auth_password_file?: string;
      auth_secret?: components["schemas"]["Secret"];
      auth_username?: string;
      from?: string;
      headers?: { [key: string]: string };
      hello?: string;
      html?: string;
      require_tls?: boolean;
      send_resolved?: boolean;
      smarthost?: components["schemas"]["HostPort"];
      text?: string;
      tls_config?: components["schemas"]["TLSConfig"];
      /** @description Email address to notify. */
      to?: string;
    };
    EmailDTO: {
      recipient?: string;
      uid?: string;
    };
    /**
     * @description EmbeddedContactPoint is the contact point type that is used
     * by grafanas embedded alertmanager implementation.
     */
    EmbeddedContactPoint: {
      /** @example false */
      disableResolveMessage?: boolean;
      /**
       * @description Name is used as grouping key in the UI. Contact points with the
       * same name will be grouped in the UI.
       * @example webhook_1
       */
      name?: string;
      provenance?: string;
      settings: components["schemas"]["Json"];
      /**
       * @example webhook
       * @enum {string}
       */
      type:
        | "alertmanager"
        | " dingding"
        | " discord"
        | " email"
        | " googlechat"
        | " kafka"
        | " line"
        | " opsgenie"
        | " pagerduty"
        | " pushover"
        | " sensugo"
        | " slack"
        | " teams"
        | " telegram"
        | " threema"
        | " victorops"
        | " webhook"
        | " wecom";
      /**
       * @description UID is the unique identifier of the contact point. The UID can be
       * set by the user.
       * @example my_external_reference
       */
      uid?: string;
    };
    /**
     * @description Enum field config
     * Vector values are used as lookup keys into the enum fields
     */
    EnumFieldConfig: {
      /** @description Color is the color value for a given index (empty is undefined) */
      color?: string[];
      /** @description Description of the enum state */
      description?: string[];
      /** @description Icon supports setting an icon for a given index value */
      icon?: string[];
      /** @description Value is the string display value for a given index */
      text?: string[];
    };
    ErrorResponseBody: {
      /** @description Error An optional detailed description of the actual error. Only included if running in developer mode. */
      error?: string;
      /** @description a human readable version of the error */
      message: string;
      /**
       * @description Status An optional status to denote the cause of the error.
       *
       * For example, a 412 Precondition Failed error may include additional information of why that error happened.
       */
      status?: string;
    };
    /** @description ErrorSource type defines the source of the error */
    ErrorSource: string;
    /** ErrorType models the different API error types. */
    ErrorType: string;
    /** @description EvalAlertConditionCommand is the command for evaluating a condition */
    EvalAlertConditionCommand: {
      condition?: string;
      data?: components["schemas"]["AlertQuery"][];
      /** Format: date-time */
      now?: string;
    };
    EvalMatch: {
      metric?: string;
      tags?: { [key: string]: string };
      value?: string;
    };
    EvalQueriesPayload: {
      condition?: string;
      data?: components["schemas"]["AlertQuery"][];
      /** Format: date-time */
      now?: string;
    };
    EvalQueriesResponse: unknown;
    /** @description This is an object constructed with the keys as the values of the enum VisType and the value being a bag of properties */
    ExplorePanelsState: unknown;
    /**
     * ExtKeyUsage represents an extended set of actions that are valid for a given key.
     * Format: int64
     * @description Each of the ExtKeyUsage* constants define a unique action.
     */
    ExtKeyUsage: number;
    ExtendedReceiver: {
      email_configs?: components["schemas"]["EmailConfig"];
      grafana_managed_receiver?: components["schemas"]["PostableGrafanaReceiver"];
      opsgenie_configs?: components["schemas"]["OpsGenieConfig"];
      pagerduty_configs?: components["schemas"]["PagerdutyConfig"];
      pushover_configs?: components["schemas"]["PushoverConfig"];
      slack_configs?: components["schemas"]["SlackConfig"];
      victorops_configs?: components["schemas"]["VictorOpsConfig"];
      webhook_configs?: components["schemas"]["WebhookConfig"];
      wechat_configs?: components["schemas"]["WechatConfig"];
    };
    /**
     * @description Extension represents the ASN.1 structure of the same name. See RFC
     * 5280, section 4.2.
     */
    Extension: {
      Critical?: boolean;
      Id?: components["schemas"]["ObjectIdentifier"];
      Value?: number[];
    };
    /** @description FailedUser holds the information of an user that failed */
    FailedUser: {
      Error?: string;
      Login?: string;
    };
    Failure: components["schemas"]["ResponseDetails"];
    /**
     * Field represents a typed column of data within a Frame.
     * @description A Field is essentially a slice of various types with extra properties and methods.
     * See NewField() for supported types.
     *
     * The slice data in the Field is a not exported, so methods on the Field are used to to manipulate its data.
     */
    Field: {
      config?: components["schemas"]["FieldConfig"];
      labels?: components["schemas"]["FrameLabels"];
      /**
       * @description Name is default identifier of the field. The name does not have to be unique, but the combination
       * of name and Labels should be unique for proper behavior in all situations.
       */
      name?: string;
    };
    /** FieldConfig represents the display properties for a Field. */
    FieldConfig: {
      /**
       * @description Map values to a display color
       * NOTE: this interface is under development in the frontend... so simple map for now
       */
      color?: { [key: string]: unknown };
      /** @description Panel Specific Values */
      custom?: { [key: string]: unknown };
      /** Format: uint16 */
      decimals?: number;
      /** @description Description is human readable field metadata */
      description?: string;
      /** @description DisplayName overrides Grafana default naming, should not be used from a data source */
      displayName?: string;
      /** @description DisplayNameFromDS overrides Grafana default naming strategy. */
      displayNameFromDS?: string;
      /** @description Filterable indicates if the Field's data can be filtered by additional calls. */
      filterable?: boolean;
      /**
       * Format: double
       * @description Interval indicates the expected regular step between values in the series.
       * When an interval exists, consumers can identify "missing" values when the expected value is not present.
       * The grafana timeseries visualization will render disconnected values when missing values are found it the time field.
       * The interval uses the same units as the values.  For time.Time, this is defined in milliseconds.
       */
      interval?: number;
      /** @description The behavior when clicking on a result */
      links?: components["schemas"]["DataLink"][];
      mappings?: components["schemas"]["ValueMappings"];
      max?: components["schemas"]["ConfFloat64"];
      min?: components["schemas"]["ConfFloat64"];
      /** @description Alternative to empty string */
      noValue?: string;
      /**
       * @description Path is an explicit path to the field in the datasource. When the frame meta includes a path,
       * this will default to `${frame.meta.path}/${field.name}
       *
       * When defined, this value can be used as an identifier within the datasource scope, and
       * may be used as an identifier to update values in a subsequent request
       */
      path?: string;
      thresholds?: components["schemas"]["ThresholdsConfig"];
      type?: components["schemas"]["FieldTypeConfig"];
      /** @description Numeric Options */
      unit?: string;
      /** @description Writeable indicates that the datasource knows how to update this value */
      writeable?: boolean;
    };
    /** @description FieldTypeConfig has type specific configs, only one should be active at a time */
    FieldTypeConfig: {
      enum?: components["schemas"]["EnumFieldConfig"];
    };
    /** FindTagsResult is the result of a tags search. */
    FindTagsResult: {
      tags?: components["schemas"]["TagsDTO"][];
    };
    /**
     * FloatHistogram is similar to Histogram but uses float64 for all
     * counts. Additionally, bucket counts are absolute and not deltas.
     * @description A FloatHistogram is needed by PromQL to handle operations that might result
     * in fractional counts. Since the counts in a histogram are unlikely to be too
     * large to be represented precisely by a float64, a FloatHistogram can also be
     * used to represent a histogram with integer counts and thus serves as a more
     * generalized representation.
     */
    FloatHistogram: {
      /**
       * Format: double
       * @description Total number of observations. Must be zero or positive.
       */
      Count?: number;
      CounterResetHint?: components["schemas"]["CounterResetHint"];
      /**
       * @description Observation counts in buckets. Each represents an absolute count and
       * must be zero or positive.
       */
      PositiveBuckets?: number[];
      /** @description Spans for positive and negative buckets (see Span below). */
      PositiveSpans?: components["schemas"]["Span"][];
      /**
       * Format: int32
       * @description Currently valid schema numbers are -4 <= n <= 8.  They are all for
       * base-2 bucket schemas, where 1 is a bucket boundary in each case, and
       * then each power of two is divided into 2^n logarithmic buckets.  Or
       * in other words, each bucket boundary is the previous boundary times
       * 2^(2^-n).
       */
      Schema?: number;
      /**
       * Format: double
       * @description Sum of observations. This is also used as the stale marker.
       */
      Sum?: number;
      /**
       * Format: double
       * @description Observations falling into the zero bucket. Must be zero or positive.
       */
      ZeroCount?: number;
      /**
       * Format: double
       * @description Width of the zero bucket.
       */
      ZeroThreshold?: number;
    };
    Folder: {
      accessControl?: components["schemas"]["Metadata"];
      canAdmin?: boolean;
      canDelete?: boolean;
      canEdit?: boolean;
      canSave?: boolean;
      /** Format: date-time */
      created?: string;
      createdBy?: string;
      hasAcl?: boolean;
      /**
       * Format: int64
       * @description Deprecated: use UID instead
       */
      id?: number;
      /** Format: int64 */
      orgId?: number;
      /** @description only used if nested folders are enabled */
      parentUid?: string;
      /** @description the parent folders starting from the root going down */
      parents?: components["schemas"]["Folder"][];
      title?: string;
      uid?: string;
      /** Format: date-time */
      updated?: string;
      updatedBy?: string;
      url?: string;
      /** Format: int64 */
      version?: number;
    };
    FolderSearchHit: {
      /** Format: int64 */
      id?: number;
      parentUid?: string;
      title?: string;
      uid?: string;
    };
    ForbiddenError: {
      body?: components["schemas"]["PublicError"];
    };
    /**
     * Frame is a columnar data structure where each column is a Field.
     * @description Each Field is well typed by its FieldType and supports optional Labels.
     *
     * A Frame is a general data container for Grafana. A Frame can be table data
     * or time series data depending on its content and field types.
     */
    Frame: {
      /**
       * @description Fields are the columns of a frame.
       * All Fields must be of the same the length when marshalling the Frame for transmission.
       * There should be no `nil` entries in the Fields slice (making them pointers was a mistake).
       */
      Fields?: components["schemas"]["Field"][];
      Meta?: components["schemas"]["FrameMeta"];
      /** @description Name is used in some Grafana visualizations. */
      Name?: string;
      /** @description RefID is a property that can be set to match a Frame to its originating query. */
      RefID?: string;
    };
    /** @description Labels are used to add metadata to an object.  The JSON will always be sorted keys */
    FrameLabels: { [key: string]: string };
    /**
     * FrameMeta matches:
     * @description https://github.com/grafana/grafana/blob/master/packages/grafana-data/src/types/data.ts#L11
     * NOTE -- in javascript this can accept any `[key: string]: any;` however
     * this interface only exposes the values we want to be exposed
     */
    FrameMeta: {
      /** @description Channel is the path to a stream in grafana live that has real-time updates for this data. */
      channel?: string;
      /** @description Custom datasource specific values. */
      custom?: unknown;
      dataTopic?: components["schemas"]["DataTopic"];
      /**
       * @description ExecutedQueryString is the raw query sent to the underlying system. All macros and templating
       * have been applied.  When metadata contains this value, it will be shown in the query inspector.
       */
      executedQueryString?: string;
      /**
       * @description Notices provide additional information about the data in the Frame that
       * Grafana can display to the user in the user interface.
       */
      notices?: components["schemas"]["Notice"][];
      /** @description Path is a browsable path on the datasource. */
      path?: string;
      /** @description PathSeparator defines the separator pattern to decode a hierarchy. The default separator is '/'. */
      pathSeparator?: string;
      /**
       * @description PreferredVisualizationPluginId sets the panel plugin id to use to render the data when using Explore. If
       * the plugin cannot be found will fall back to PreferredVisualization.
       */
      preferredVisualisationPluginId?: string;
      preferredVisualisationType?: components["schemas"]["VisType"];
      /** @description Stats is an array of query result statistics. */
      stats?: components["schemas"]["QueryStat"][];
      type?: components["schemas"]["FrameType"];
      typeVersion?: components["schemas"]["FrameTypeVersion"];
      /**
       * @description Array of field indices which values create a unique id for each row. Ideally this should be globally unique ID
       * but that isn't guarantied. Should help with keeping track and deduplicating rows in visualizations, especially
       * with streaming data with frequent updates.
       * @example TraceID in Tempo, table name + primary key in SQL
       */
      uniqueRowIdFields?: number[];
    };
    /**
     * @description A FrameType string, when present in a frame's metadata, asserts that the
     * frame's structure conforms to the FrameType's specification.
     * This property is currently optional, so FrameType may be FrameTypeUnknown even if the properties of
     * the Frame correspond to a defined FrameType.
     */
    FrameType: string;
    /** FrameType is a 2 number version (Major / Minor). */
    FrameTypeVersion: number[];
    /**
     * Frames is a slice of Frame pointers.
     * @description It is the main data container within a backend.DataResponse.
     * There should be no `nil` entries in the Frames slice (making them pointers was a mistake).
     */
    Frames: components["schemas"]["Frame"][];
    GenericPublicError: {
      body?: components["schemas"]["PublicError"];
    };
    /** GetAnnotationTagsResponse is a response struct for FindTagsResult. */
    GetAnnotationTagsResponse: {
      result?: components["schemas"]["FindTagsResult"];
    };
    /** Get home dashboard response. */
    GetHomeDashboardResponse: {
      dashboard?: components["schemas"]["Json"];
      meta?: components["schemas"]["DashboardMeta"];
    } & {
      redirectUri?: string;
    };
    GettableAlertmanagers: {
      data?: components["schemas"]["AlertManagersResult"];
      status?: string;
    };
    GettableApiAlertingConfig: {
      global?: components["schemas"]["GlobalConfig"];
      inhibit_rules?: components["schemas"]["InhibitRule"][];
      muteTimeProvenances?: {
        [key: string]: components["schemas"]["Provenance"];
      };
      mute_time_intervals?: components["schemas"]["MuteTimeInterval"][];
      /** @description Override with our superset receiver type */
      receivers?: components["schemas"]["GettableApiReceiver"][];
      route?: components["schemas"]["Route"];
      templates?: string[];
    };
    GettableApiReceiver: {
      discord_configs?: components["schemas"]["DiscordConfig"][];
      email_configs?: components["schemas"]["EmailConfig"][];
      grafana_managed_receiver_configs?: components["schemas"]["GettableGrafanaReceiver"][];
      msteams_configs?: components["schemas"]["MSTeamsConfig"][];
      /** @description A unique identifier for this receiver. */
      name?: string;
      opsgenie_configs?: components["schemas"]["OpsGenieConfig"][];
      pagerduty_configs?: components["schemas"]["PagerdutyConfig"][];
      pushover_configs?: components["schemas"]["PushoverConfig"][];
      slack_configs?: components["schemas"]["SlackConfig"][];
      sns_configs?: components["schemas"]["SNSConfig"][];
      telegram_configs?: components["schemas"]["TelegramConfig"][];
      victorops_configs?: components["schemas"]["VictorOpsConfig"][];
      webex_configs?: components["schemas"]["WebexConfig"][];
      webhook_configs?: components["schemas"]["WebhookConfig"][];
      wechat_configs?: components["schemas"]["WechatConfig"][];
    };
    GettableExtendedRuleNode: {
      alert?: string;
      annotations?: { [key: string]: string };
      expr?: string;
      for?: string;
      grafana_alert?: components["schemas"]["GettableGrafanaRule"];
      keep_firing_for?: string;
      labels?: { [key: string]: string };
      record?: string;
    };
    GettableGrafanaReceiver: {
      disableResolveMessage?: boolean;
      name?: string;
      provenance?: components["schemas"]["Provenance"];
      secureFields?: { [key: string]: boolean };
      settings?: components["schemas"]["RawMessage"];
      type?: string;
      uid?: string;
    };
    GettableGrafanaReceivers: {
      grafana_managed_receiver_configs?: components["schemas"]["GettableGrafanaReceiver"][];
    };
    GettableGrafanaRule: {
      condition?: string;
      data?: components["schemas"]["AlertQuery"][];
      /** @enum {string} */
      exec_err_state?: "OK" | "Alerting" | "Error";
      /** Format: int64 */
      id?: number;
      /** Format: int64 */
      intervalSeconds?: number;
      is_paused?: boolean;
      namespace_uid?: string;
      /** @enum {string} */
      no_data_state?: "Alerting" | "NoData" | "OK";
      /** Format: int64 */
      orgId?: number;
      provenance?: components["schemas"]["Provenance"];
      rule_group?: string;
      title?: string;
      uid?: string;
      /** Format: date-time */
      updated?: string;
      /** Format: int64 */
      version?: number;
    };
    GettableHistoricUserConfig: {
      alertmanager_config?: components["schemas"]["GettableApiAlertingConfig"];
      /** Format: int64 */
      id?: number;
      /** Format: date-time */
      last_applied?: string;
      template_file_provenances?: {
        [key: string]: components["schemas"]["Provenance"];
      };
      template_files?: { [key: string]: string };
    };
    GettableNGalertConfig: {
      /** @enum {string} */
      alertmanagersChoice?: "all" | "internal" | "external";
    };
    GettableRuleGroupConfig: {
      interval?: components["schemas"]["Duration"];
      name?: string;
      rules?: components["schemas"]["GettableExtendedRuleNode"][];
      source_tenants?: string[];
    };
    GettableStatus: {
      cluster: components["schemas"]["clusterStatus"];
      config: components["schemas"]["PostableApiAlertingConfig"];
      /**
       * Format: date-time
       * @description uptime
       */
      uptime: string;
      versionInfo: components["schemas"]["versionInfo"];
    };
    GettableTimeIntervals: {
      name?: string;
      provenance?: components["schemas"]["Provenance"];
      time_intervals?: components["schemas"]["TimeIntervalItem"][];
    };
    GettableUserConfig: {
      alertmanager_config?: components["schemas"]["GettableApiAlertingConfig"];
      template_file_provenances?: {
        [key: string]: components["schemas"]["Provenance"];
      };
      template_files?: { [key: string]: string };
    };
    /**
     * @description GlobalConfig defines configuration parameters that are valid globally
     * unless overwritten.
     */
    GlobalConfig: {
      http_config?: components["schemas"]["HTTPClientConfig"];
      opsgenie_api_key?: components["schemas"]["Secret"];
      opsgenie_api_key_file?: string;
      opsgenie_api_url?: components["schemas"]["URL"];
      pagerduty_url?: components["schemas"]["URL"];
      resolve_timeout?: components["schemas"]["Duration"];
      slack_api_url?: components["schemas"]["SecretURL"];
      slack_api_url_file?: string;
      smtp_auth_identity?: string;
      smtp_auth_password?: components["schemas"]["Secret"];
      smtp_auth_password_file?: string;
      smtp_auth_secret?: components["schemas"]["Secret"];
      smtp_auth_username?: string;
      smtp_from?: string;
      smtp_hello?: string;
      smtp_require_tls?: boolean;
      smtp_smarthost?: components["schemas"]["HostPort"];
      telegram_api_url?: components["schemas"]["URL"];
      victorops_api_key?: components["schemas"]["Secret"];
      victorops_api_key_file?: string;
      victorops_api_url?: components["schemas"]["URL"];
      webex_api_url?: components["schemas"]["URL"];
      wechat_api_corp_id?: string;
      wechat_api_secret?: components["schemas"]["Secret"];
      wechat_api_url?: components["schemas"]["URL"];
    };
    /** HTTPClientConfig configures an HTTP client. */
    HTTPClientConfig: {
      authorization?: components["schemas"]["Authorization"];
      basic_auth?: components["schemas"]["BasicAuth"];
      bearer_token?: components["schemas"]["Secret"];
      /**
       * @description The bearer token file for the targets. Deprecated in favour of
       * Authorization.CredentialsFile.
       */
      bearer_token_file?: string;
      /**
       * @description EnableHTTP2 specifies whether the client should configure HTTP2.
       * The omitempty flag is not set, because it would be hidden from the
       * marshalled configuration when set to false.
       */
      enable_http2?: boolean;
      /**
       * @description FollowRedirects specifies whether the client should follow HTTP 3xx redirects.
       * The omitempty flag is not set, because it would be hidden from the
       * marshalled configuration when set to false.
       */
      follow_redirects?: boolean;
      /** @description NoProxy contains addresses that should not use a proxy. */
      no_proxy?: string;
      oauth2?: components["schemas"]["OAuth2"];
      proxy_connect_header?: components["schemas"]["Header"];
      /**
       * @description ProxyFromEnvironment makes use of net/http ProxyFromEnvironment function
       * to determine proxies.
       */
      proxy_from_environment?: boolean;
      proxy_url?: components["schemas"]["URL"];
      tls_config?: components["schemas"]["TLSConfig"];
    };
    Header: { [key: string]: components["schemas"]["Secret"][] };
    Hit: {
      /**
       * Format: int64
       * @description Deprecated: use FolderUID instead
       */
      folderId?: number;
      folderTitle?: string;
      folderUid?: string;
      folderUrl?: string;
      /** Format: int64 */
      id?: number;
      isStarred?: boolean;
      slug?: string;
      /** Format: int64 */
      sortMeta?: number;
      sortMetaName?: string;
      tags?: string[];
      title?: string;
      type?: components["schemas"]["HitType"];
      uid?: string;
      uri?: string;
      url?: string;
    };
    HitList: components["schemas"]["Hit"][];
    HitType: string;
    /** HostPort represents a "host:port" network address. */
    HostPort: {
      Host?: string;
      Port?: string;
    };
    /**
     * An IPMask is a bitmask that can be used to manipulate
     * IP addresses for IP addressing and routing.
     * @description See type IPNet and func ParseCIDR for details.
     */
    IPMask: number[];
    /** An IPNet represents an IP network. */
    IPNet: {
      IP?: string;
      Mask?: components["schemas"]["IPMask"];
    };
    /** ImportDashboardInput definition of input parameters when importing a dashboard. */
    ImportDashboardInput: {
      name?: string;
      pluginId?: string;
      type?: string;
      value?: string;
    };
    /** ImportDashboardRequest request object for importing a dashboard. */
    ImportDashboardRequest: {
      dashboard?: components["schemas"]["Json"];
      /**
       * Format: int64
       * @description Deprecated: use FolderUID instead
       */
      folderId?: number;
      folderUid?: string;
      inputs?: components["schemas"]["ImportDashboardInput"][];
      overwrite?: boolean;
      path?: string;
      pluginId?: string;
    };
    /** ImportDashboardResponse response object returned when importing a dashboard. */
    ImportDashboardResponse: {
      /** Format: int64 */
      dashboardId?: number;
      description?: string;
      /**
       * Format: int64
       * @description Deprecated: use FolderUID instead
       */
      folderId?: number;
      folderUid?: string;
      imported?: boolean;
      /** Format: int64 */
      importedRevision?: number;
      importedUri?: string;
      importedUrl?: string;
      path?: string;
      pluginId?: string;
      removed?: boolean;
      /** Format: int64 */
      revision?: number;
      slug?: string;
      title?: string;
      uid?: string;
    };
    /**
     * @description InhibitRule defines an inhibition rule that mutes alerts that match the
     * target labels if an alert matching the source labels exists.
     * Both alerts have to have a set of labels being equal.
     */
    InhibitRule: {
      equal?: components["schemas"]["LabelNames"];
      /**
       * @description SourceMatch defines a set of labels that have to equal the given
       * value for source alerts. Deprecated. Remove before v1.0 release.
       */
      source_match?: { [key: string]: string };
      source_match_re?: components["schemas"]["MatchRegexps"];
      source_matchers?: components["schemas"]["Matchers"];
      /**
       * @description TargetMatch defines a set of labels that have to equal the given
       * value for target alerts. Deprecated. Remove before v1.0 release.
       */
      target_match?: { [key: string]: string };
      target_match_re?: components["schemas"]["MatchRegexps"];
      target_matchers?: components["schemas"]["Matchers"];
    };
    /**
     * InspectType is a type for the Inspect property of a Notice.
     * Format: int64
     */
    InspectType: number;
    /** @description InternalDataLink definition to allow Explore links to be constructed in the backend */
    InternalDataLink: {
      datasourceName?: string;
      datasourceUid?: string;
      panelsState?: components["schemas"]["ExplorePanelsState"];
      query?: unknown;
      timeRange?: components["schemas"]["TimeRange"];
      transformations?: components["schemas"]["LinkTransformationConfig"][];
    };
    /** JSONWebKey represents a public or private key in JWK format. */
    JSONWebKey: {
      /** @description Key algorithm, parsed from `alg` header. */
      Algorithm?: string;
      /** @description X.509 certificate thumbprint (SHA-1), parsed from `x5t` header. */
      CertificateThumbprintSHA1?: number[];
      /** @description X.509 certificate thumbprint (SHA-256), parsed from `x5t#S256` header. */
      CertificateThumbprintSHA256?: number[];
      /** @description X.509 certificate chain, parsed from `x5c` header. */
      Certificates?: components["schemas"]["Certificate"][];
      CertificatesURL?: components["schemas"]["URL"];
      /** @description Cryptographic key, can be a symmetric or asymmetric key. */
      Key?: unknown;
      /** @description Key identifier, parsed from `kid` header. */
      KeyID?: string;
      /** @description Key use, parsed from `use` header. */
      Use?: string;
    };
    Json: { [key: string]: unknown };
    /**
     * Format: int64
     * @description KeyUsage represents the set of actions that are valid for a given key. It's
     * a bitmap of the KeyUsage* constants.
     */
    KeyUsage: number;
    /** Label is a key/value pair of strings. */
    Label: {
      Name?: string;
    };
    /**
     * @description A LabelName is a key for a LabelSet or Metric.  It has a value associated
     * therewith.
     */
    LabelName: string;
    /** LabelNames is a sortable LabelName slice. In implements sort.Interface. */
    LabelNames: components["schemas"]["LabelName"][];
    /**
     * @description A LabelSet is a collection of LabelName and LabelValue pairs.  The LabelSet
     * may be fully-qualified down to the point where it may resolve to a single
     * Metric in the data store or not.  All operations that occur within the realm
     * of a LabelSet can emit a vector of Metric entities to which the LabelSet may
     * match.
     */
    LabelSet: { [key: string]: components["schemas"]["LabelValue"] };
    /** A LabelValue is an associated value for a LabelName. */
    LabelValue: string;
    /**
     * @description Labels is a sorted set of labels. Order has to be guaranteed upon
     * instantiation.
     */
    Labels: components["schemas"]["Label"][];
    LegacyAlert: {
      /** Format: date-time */
      Created?: string;
      /** Format: int64 */
      DashboardID?: number;
      EvalData?: components["schemas"]["Json"];
      ExecutionError?: string;
      For?: components["schemas"]["Duration"];
      /** Format: int64 */
      Frequency?: number;
      /** Format: int64 */
      Handler?: number;
      /** Format: int64 */
      ID?: number;
      Message?: string;
      Name?: string;
      /** Format: date-time */
      NewStateDate?: string;
      /** Format: int64 */
      OrgID?: number;
      /** Format: int64 */
      PanelID?: number;
      Settings?: components["schemas"]["Json"];
      Severity?: string;
      Silenced?: boolean;
      State?: components["schemas"]["AlertStateType"];
      /** Format: int64 */
      StateChanges?: number;
      /** Format: date-time */
      Updated?: string;
      /** Format: int64 */
      Version?: number;
    };
    LegacyChannel: {
      /** Format: int64 */
      id?: number;
      name?: string;
      type?: string;
    };
    /** LibraryElementArrayResponse is a response struct for an array of LibraryElementDTO. */
    LibraryElementArrayResponse: {
      result?: components["schemas"]["LibraryElementDTO"][];
    };
    /** LibraryElementConnectionDTO is the frontend DTO for element connections. */
    LibraryElementConnectionDTO: {
      /** Format: int64 */
      connectionId?: number;
      connectionUid?: string;
      /** Format: date-time */
      created?: string;
      createdBy?: components["schemas"]["LibraryElementDTOMetaUser"];
      /** Format: int64 */
      elementId?: number;
      /** Format: int64 */
      id?: number;
      /** Format: int64 */
      kind?: number;
    };
    /** LibraryElementConnectionsResponse is a response struct for an array of LibraryElementConnectionDTO. */
    LibraryElementConnectionsResponse: {
      result?: components["schemas"]["LibraryElementConnectionDTO"][];
    };
    /** LibraryElementDTO is the frontend DTO for entities. */
    LibraryElementDTO: {
      description?: string;
      /**
       * Format: int64
       * @description Deprecated: use FolderUID instead
       */
      folderId?: number;
      folderUid?: string;
      /** Format: int64 */
      id?: number;
      /** Format: int64 */
      kind?: number;
      meta?: components["schemas"]["LibraryElementDTOMeta"];
      model?: { [key: string]: unknown };
      name?: string;
      /** Format: int64 */
      orgId?: number;
      /** Format: int64 */
      schemaVersion?: number;
      type?: string;
      uid?: string;
      /** Format: int64 */
      version?: number;
    };
    /** LibraryElementDTOMeta is the meta information for LibraryElementDTO. */
    LibraryElementDTOMeta: {
      /** Format: int64 */
      connectedDashboards?: number;
      /** Format: date-time */
      created?: string;
      createdBy?: components["schemas"]["LibraryElementDTOMetaUser"];
      folderName?: string;
      folderUid?: string;
      /** Format: date-time */
      updated?: string;
      updatedBy?: components["schemas"]["LibraryElementDTOMetaUser"];
    };
    /** LibraryElementDTOMetaUser defines model for LibraryElementDTOMetaUser. */
    LibraryElementDTOMetaUser: {
      avatarUrl?: string;
      /** Format: int64 */
      id?: number;
      name?: string;
    };
    /** LibraryElementResponse is a response struct for LibraryElementDTO. */
    LibraryElementResponse: {
      result?: components["schemas"]["LibraryElementDTO"];
    };
    /** LibraryElementSearchResponse is a response struct for LibraryElementSearchResult. */
    LibraryElementSearchResponse: {
      result?: components["schemas"]["LibraryElementSearchResult"];
    };
    /** LibraryElementSearchResult is the search result for entities. */
    LibraryElementSearchResult: {
      elements?: components["schemas"]["LibraryElementDTO"][];
      /** Format: int64 */
      page?: number;
      /** Format: int64 */
      perPage?: number;
      /** Format: int64 */
      totalCount?: number;
    };
    LinkTransformationConfig: {
      expression?: string;
      field?: string;
      mapValue?: string;
      type?: components["schemas"]["SupportedTransformationTypes"];
    };
    MSTeamsConfig: {
      http_config?: components["schemas"]["HTTPClientConfig"];
      send_resolved?: boolean;
      text?: string;
      title?: string;
      webhook_url?: components["schemas"]["SecretURL"];
    };
    MassDeleteAnnotationsCmd: {
      /** Format: int64 */
      annotationId?: number;
      /** Format: int64 */
      dashboardId?: number;
      dashboardUID?: string;
      /** Format: int64 */
      panelId?: number;
    };
    /** MatchRegexps represents a map of Regexp. */
    MatchRegexps: { [key: string]: string };
    /**
     * MatchType is an enum for label matching types.
     * Format: int64
     */
    MatchType: number;
    /** Matcher models the matching of a label. */
    Matcher: {
      Name?: string;
      Type?: components["schemas"]["MatchType"];
      Value?: string;
    };
    /**
     * @description Matchers is a slice of Matchers that is sortable, implements Stringer, and
     * provides a Matches method to match a LabelSet against all Matchers in the
     * slice. Note that some users of Matchers might require it to be sorted.
     */
    Matchers: components["schemas"]["Matcher"][];
    /**
     * @description Metadata contains user accesses for a given resource
     * Ex: map[string]bool{"create":true, "delete": true}
     */
    Metadata: { [key: string]: boolean };
    MetricRequest: {
      debug?: boolean;
      /**
       * @description From Start time in epoch timestamps in milliseconds or relative using Grafana time units.
       * @example now-1h
       */
      from: string;
      /**
       * @description queries.refId – Specifies an identifier of the query. Is optional and default to “A”.
       * queries.datasourceId – Specifies the data source to be queried. Each query in the request must have an unique datasourceId.
       * queries.maxDataPoints - Species maximum amount of data points that dashboard panel can render. Is optional and default to 100.
       * queries.intervalMs - Specifies the time interval in milliseconds of time series. Is optional and defaults to 1000.
       * @example [
       *   {
       *     "datasource": {
       *       "uid": "PD8C576611E62080A"
       *     },
       *     "format": "table",
       *     "intervalMs": 86400000,
       *     "maxDataPoints": 1092,
       *     "rawSql": "SELECT 1 as valueOne, 2 as valueTwo",
       *     "refId": "A"
       *   }
       * ]
       */
      queries: components["schemas"]["Json"][];
      /**
       * @description To End time in epoch timestamps in milliseconds or relative using Grafana time units.
       * @example now
       */
      to: string;
    };
    /**
     * @description MoveFolderCommand captures the information required by the folder service
     * to move a folder.
     */
    MoveFolderCommand: {
      parentUid?: string;
    };
    MultiStatus: { [key: string]: unknown };
    /** MuteTimeInterval represents a named set of time intervals for which a route should be muted. */
    MuteTimeInterval: {
      name?: string;
      time_intervals?: components["schemas"]["TimeInterval"][];
    };
    MuteTimeIntervalExport: {
      name?: string;
      /** Format: int64 */
      orgId?: number;
      time_intervals?: components["schemas"]["TimeInterval"][];
    };
    MuteTimings: components["schemas"]["MuteTimeInterval"][];
    /**
     * @description Name represents an X.509 distinguished name. This only includes the common
     * elements of a DN. Note that Name is only an approximation of the X.509
     * structure. If an accurate representation is needed, asn1.Unmarshal the raw
     * subject or issuer as an RDNSequence.
     */
    Name: {
      Country?: string[];
      /**
       * @description ExtraNames contains attributes to be copied, raw, into any marshaled
       * distinguished names. Values override any attributes with the same OID.
       * The ExtraNames field is not populated when parsing, see Names.
       */
      ExtraNames?: components["schemas"]["AttributeTypeAndValue"][];
      Locality?: string[];
      /**
       * @description Names contains all parsed attributes. When parsing distinguished names,
       * this can be used to extract non-standard attributes that are not parsed
       * by this package. When marshaling to RDNSequences, the Names field is
       * ignored, see ExtraNames.
       */
      Names?: components["schemas"]["AttributeTypeAndValue"][];
      SerialNumber?: string;
      StreetAddress?: string[];
    };
    NamespaceConfigResponse: {
      [key: string]: components["schemas"]["GettableRuleGroupConfig"][];
    };
    NewApiKeyResult: {
      /**
       * Format: int64
       * @example 1
       */
      id?: number;
      /** @example glsa_yscW25imSKJIuav8zF37RZmnbiDvB05G_fcaaf58a */
      key?: string;
      /** @example grafana */
      name?: string;
    };
    NotFound: { [key: string]: unknown };
    /** Notice provides a structure for presenting notifications in Grafana's user interface. */
    Notice: {
      inspect?: components["schemas"]["InspectType"];
      /**
       * @description Link is an optional link for display in the user interface and can be an
       * absolute URL or a path relative to Grafana's root url.
       */
      link?: string;
      severity?: components["schemas"]["NoticeSeverity"];
      /** @description Text is freeform descriptive text for the notice. */
      text?: string;
    };
    /**
     * NoticeSeverity is a type for the Severity property of a Notice.
     * Format: int64
     */
    NoticeSeverity: number;
    /** NotificationPolicyExport is the provisioned file export of alerting.NotificiationPolicyV1. */
    NotificationPolicyExport: {
      continue?: boolean;
      group_by?: string[];
      group_interval?: string;
      group_wait?: string;
      /** @description Deprecated. Remove before v1.0 release. */
      match?: { [key: string]: string };
      match_re?: components["schemas"]["MatchRegexps"];
      matchers?: components["schemas"]["Matchers"];
      mute_time_intervals?: string[];
      object_matchers?: components["schemas"]["ObjectMatchers"];
      /** Format: int64 */
      orgId?: number;
      receiver?: string;
      repeat_interval?: string;
      routes?: components["schemas"]["RouteExport"][];
    };
    NotificationTemplate: {
      name?: string;
      provenance?: components["schemas"]["Provenance"];
      template?: string;
    };
    NotificationTemplateContent: {
      template?: string;
    };
    NotificationTemplates: components["schemas"]["NotificationTemplate"][];
    NotificationTestCommand: {
      disableResolveMessage?: boolean;
      frequency?: string;
      /** Format: int64 */
      id?: number;
      name?: string;
      secureSettings?: { [key: string]: string };
      sendReminder?: boolean;
      settings?: components["schemas"]["Json"];
      type?: string;
    };
    /** NotifierConfig contains base options common across all notifier configurations. */
    NotifierConfig: {
      send_resolved?: boolean;
    };
    /** OAuth2 is the oauth2 client configuration. */
    OAuth2: {
      TLSConfig?: components["schemas"]["TLSConfig"];
      client_id?: string;
      client_secret?: components["schemas"]["Secret"];
      client_secret_file?: string;
      endpoint_params?: { [key: string]: string };
      /** @description NoProxy contains addresses that should not use a proxy. */
      no_proxy?: string;
      proxy_connect_header?: components["schemas"]["Header"];
      /**
       * @description ProxyFromEnvironment makes use of net/http ProxyFromEnvironment function
       * to determine proxies.
       */
      proxy_from_environment?: boolean;
      proxy_url?: components["schemas"]["URL"];
      scopes?: string[];
      token_url?: string;
    };
    /** An ObjectIdentifier represents an ASN.1 OBJECT IDENTIFIER. */
    ObjectIdentifier: number[];
    /** ObjectMatcher is a matcher that can be used to filter alerts. */
    ObjectMatcher: string[];
    ObjectMatchers: components["schemas"]["ObjectMatcher"][];
    /** OpsGenieConfig configures notifications via OpsGenie. */
    OpsGenieConfig: {
      actions?: string;
      api_key?: components["schemas"]["Secret"];
      api_key_file?: string;
      api_url?: components["schemas"]["URL"];
      description?: string;
      details?: { [key: string]: string };
      entity?: string;
      http_config?: components["schemas"]["HTTPClientConfig"];
      message?: string;
      note?: string;
      priority?: string;
      responders?: components["schemas"]["OpsGenieConfigResponder"][];
      send_resolved?: boolean;
      source?: string;
      tags?: string;
      update_alerts?: boolean;
    };
    OpsGenieConfigResponder: {
      /** @description One of those 3 should be filled. */
      id?: string;
      name?: string;
      /** @description team, user, escalation, schedule etc. */
      type?: string;
      username?: string;
    };
    OrgDTO: {
      /** Format: int64 */
      id?: number;
      name?: string;
    };
    OrgDetailsDTO: {
      address?: components["schemas"]["Address"];
      /** Format: int64 */
      id?: number;
      name?: string;
    };
    OrgMigrationState: {
      migratedChannels?: components["schemas"]["ContactPair"][];
      migratedDashboards?: components["schemas"]["DashboardUpgrade"][];
      /** Format: int64 */
      orgId?: number;
    };
    OrgMigrationSummary: {
      hasErrors?: boolean;
      /** Format: int64 */
      newAlerts?: number;
      /** Format: int64 */
      newChannels?: number;
      /** Format: int64 */
      newDashboards?: number;
      removed?: boolean;
    };
    OrgUserDTO: {
      accessControl?: { [key: string]: boolean };
      authLabels?: string[];
      avatarUrl?: string;
      email?: string;
      isDisabled?: boolean;
      isExternallySynced?: boolean;
      /** Format: date-time */
      lastSeenAt?: string;
      lastSeenAtAge?: string;
      login?: string;
      name?: string;
      /** Format: int64 */
      orgId?: number;
      role?: string;
      /** Format: int64 */
      userId?: number;
    };
    /** PagerdutyConfig configures notifications via PagerDuty. */
    PagerdutyConfig: {
      class?: string;
      client?: string;
      client_url?: string;
      component?: string;
      description?: string;
      details?: { [key: string]: string };
      group?: string;
      http_config?: components["schemas"]["HTTPClientConfig"];
      images?: components["schemas"]["PagerdutyImage"][];
      links?: components["schemas"]["PagerdutyLink"][];
      routing_key?: components["schemas"]["Secret"];
      routing_key_file?: string;
      send_resolved?: boolean;
      service_key?: components["schemas"]["Secret"];
      service_key_file?: string;
      severity?: string;
      source?: string;
      url?: components["schemas"]["URL"];
    };
    /** @description PagerdutyImage is an image */
    PagerdutyImage: {
      alt?: string;
      href?: string;
      src?: string;
    };
    /** @description PagerdutyLink is a link */
    PagerdutyLink: {
      href?: string;
      text?: string;
    };
    Password: string;
    PatchAnnotationsCmd: {
      data?: components["schemas"]["Json"];
      /** Format: int64 */
      id?: number;
      tags?: string[];
      text?: string;
      /** Format: int64 */
      time?: number;
      /** Format: int64 */
      timeEnd?: number;
    };
    /** @description PatchLibraryElementCommand is the command for patching a LibraryElement */
    PatchLibraryElementCommand: {
      /**
       * Format: int64
       * @description ID of the folder where the library element is stored.
       *
       * Deprecated: use FolderUID instead
       */
      folderId?: number;
      /** @description UID of the folder where the library element is stored. */
      folderUid?: string;
      /**
       * Format: int64
       * @description Kind of element to create, Use 1 for library panels or 2 for c.
       * Description:
       * 1 - library panels
       * 2 - library variables
       * @enum {integer}
       */
      kind?: 1 | 2;
      /** @description The JSON model for the library element. */
      model?: { [key: string]: unknown };
      /** @description Name of the library element. */
      name?: string;
      uid?: string;
      /**
       * Format: int64
       * @description Version of the library element you are updating.
       */
      version?: number;
    };
    PatchPrefsCmd: {
      cookies?: components["schemas"]["CookieType"][];
      /**
       * Format: int64
       * @description The numerical :id of a favorited dashboard
       * @default 0
       */
      homeDashboardId?: number;
      homeDashboardUID?: string;
      language?: string;
      queryHistory?: components["schemas"]["QueryHistoryPreference"];
      /** @enum {string} */
      theme?: "light" | "dark";
      /** @enum {string} */
      timezone?: "utc" | "browser";
      weekStart?: string;
    };
    /** @description PatchQueryCommentInQueryHistoryCommand is the command for updating comment for query in query history */
    PatchQueryCommentInQueryHistoryCommand: {
      /** @description Updated comment */
      comment?: string;
    };
    PauseAlertCommand: {
      /** Format: int64 */
      alertId?: number;
      paused?: boolean;
    };
    PauseAllAlertsCommand: {
      paused?: boolean;
    };
    /** Permission is the model for access control permissions. */
    Permission: {
      action?: string;
      /** Format: date-time */
      created?: string;
      scope?: string;
      /** Format: date-time */
      updated?: string;
    };
    PermissionDenied: { [key: string]: unknown };
    /** Format: int64 */
    PermissionType: number;
    /** @description Playlist model */
    Playlist: {
      /** Format: int64 */
      id?: number;
      interval?: string;
      name?: string;
      uid?: string;
    };
    PlaylistDTO: {
      /** @description Interval sets the time between switching views in a playlist. */
      interval?: string;
      /** @description The ordered list of items that the playlist will iterate over. */
      items?: components["schemas"]["PlaylistItemDTO"][];
      /** @description Name of the playlist. */
      name?: string;
      /**
       * @description Unique playlist identifier. Generated on creation, either by the
       * creator of the playlist of by the application.
       */
      uid?: string;
    };
    PlaylistDashboard: {
      /** Format: int64 */
      id?: number;
      /** Format: int64 */
      order?: number;
      slug?: string;
      title?: string;
      uri?: string;
      url?: string;
    };
    PlaylistDashboardsSlice: components["schemas"]["PlaylistDashboard"][];
    PlaylistItem: {
      /** Format: int64 */
      Id?: number;
      /** Format: int64 */
      PlaylistId?: number;
      /** Format: int64 */
      order?: number;
      title?: string;
      type?: string;
      value?: string;
    };
    PlaylistItemDTO: {
      /** @description Title is an unused property -- it will be removed in the future */
      title?: string;
      /** @description Type of the item. */
      type?: string;
      /**
       * @description Value depends on type and describes the playlist item.
       *
       * dashboard_by_id: The value is an internal numerical identifier set by Grafana. This
       * is not portable as the numerical identifier is non-deterministic between different instances.
       * Will be replaced by dashboard_by_uid in the future. (deprecated)
       * dashboard_by_tag: The value is a tag which is set on any number of dashboards. All
       * dashboards behind the tag will be added to the playlist.
       * dashboard_by_uid: The value is the dashboard UID
       */
      value?: string;
    };
    Playlists: components["schemas"]["Playlist"][];
    /**
     * Point represents a single data point for a given timestamp.
     * @description If H is not nil, then this is a histogram point and only (T, H) is valid.
     * If H is nil, then only (T, V) is valid.
     */
    Point: {
      H?: components["schemas"]["FloatHistogram"];
      /** Format: int64 */
      T?: number;
      /** Format: double */
      V?: number;
    };
    PostAnnotationsCmd: {
      /** Format: int64 */
      dashboardId?: number;
      dashboardUID?: string;
      data?: components["schemas"]["Json"];
      /** Format: int64 */
      panelId?: number;
      tags?: string[];
      text: string;
      /** Format: int64 */
      time?: number;
      /** Format: int64 */
      timeEnd?: number;
    };
    PostGraphiteAnnotationsCmd: {
      data?: string;
      tags?: unknown;
      what?: string;
      /** Format: int64 */
      when?: number;
    };
    PostableApiAlertingConfig: {
      global?: components["schemas"]["GlobalConfig"];
      inhibit_rules?: components["schemas"]["InhibitRule"][];
      mute_time_intervals?: components["schemas"]["MuteTimeInterval"][];
      /** @description Override with our superset receiver type */
      receivers?: components["schemas"]["PostableApiReceiver"][];
      route?: components["schemas"]["Route"];
      templates?: string[];
    };
    PostableApiReceiver: {
      discord_configs?: components["schemas"]["DiscordConfig"][];
      email_configs?: components["schemas"]["EmailConfig"][];
      grafana_managed_receiver_configs?: components["schemas"]["PostableGrafanaReceiver"][];
      msteams_configs?: components["schemas"]["MSTeamsConfig"][];
      /** @description A unique identifier for this receiver. */
      name?: string;
      opsgenie_configs?: components["schemas"]["OpsGenieConfig"][];
      pagerduty_configs?: components["schemas"]["PagerdutyConfig"][];
      pushover_configs?: components["schemas"]["PushoverConfig"][];
      slack_configs?: components["schemas"]["SlackConfig"][];
      sns_configs?: components["schemas"]["SNSConfig"][];
      telegram_configs?: components["schemas"]["TelegramConfig"][];
      victorops_configs?: components["schemas"]["VictorOpsConfig"][];
      webex_configs?: components["schemas"]["WebexConfig"][];
      webhook_configs?: components["schemas"]["WebhookConfig"][];
      wechat_configs?: components["schemas"]["WechatConfig"][];
    };
    PostableExtendedRuleNode: {
      alert?: string;
      annotations?: { [key: string]: string };
      expr?: string;
      for?: string;
      grafana_alert?: components["schemas"]["PostableGrafanaRule"];
      keep_firing_for?: string;
      labels?: { [key: string]: string };
      record?: string;
    };
    PostableExtendedRuleNodeExtended: {
      /** @example project_x */
      folderTitle?: string;
      /** @example okrd3I0Vz */
      folderUid?: string;
      rule: components["schemas"]["PostableExtendedRuleNode"];
      /** @example eval_group_1 */
      ruleGroup?: string;
    };
    PostableGrafanaReceiver: {
      disableResolveMessage?: boolean;
      name?: string;
      secureSettings?: { [key: string]: string };
      settings?: components["schemas"]["RawMessage"];
      type?: string;
      uid?: string;
    };
    PostableGrafanaReceivers: {
      grafana_managed_receiver_configs?: components["schemas"]["PostableGrafanaReceiver"][];
    };
    PostableGrafanaRule: {
      condition?: string;
      data?: components["schemas"]["AlertQuery"][];
      /** @enum {string} */
      exec_err_state?: "OK" | "Alerting" | "Error";
      is_paused?: boolean;
      /** @enum {string} */
      no_data_state?: "Alerting" | "NoData" | "OK";
      title?: string;
      uid?: string;
    };
    PostableNGalertConfig: {
      /** @enum {string} */
      alertmanagersChoice?: "all" | "internal" | "external";
    };
    PostableRuleGroupConfig: {
      interval?: components["schemas"]["Duration"];
      name?: string;
      rules?: components["schemas"]["PostableExtendedRuleNode"][];
    };
    PostableTimeIntervals: {
      name?: string;
      time_intervals?: components["schemas"]["TimeIntervalItem"][];
    };
    PostableUserConfig: {
      alertmanager_config?: components["schemas"]["PostableApiAlertingConfig"];
      template_files?: { [key: string]: string };
    };
    /** @description Spec defines user, team or org Grafana preferences */
    Preferences: {
      cookiePreferences?: components["schemas"]["CookiePreferences"];
      /** @description UID for the home dashboard */
      homeDashboardUID?: string;
      /** @description Selected language (beta) */
      language?: string;
      queryHistory?: components["schemas"]["QueryHistoryPreference"];
      /** @description Theme light, dark, empty is default */
      theme?: string;
      /**
       * @description The timezone selection
       * TODO: this should use the timezone defined in common
       */
      timezone?: string;
      /** @description WeekStart day of the week (sunday, monday, etc) */
      weekStart?: string;
    };
    PrometheusRemoteWriteTargetJSON: {
      data_source_uid?: string;
      id?: string;
      remote_write_path?: string;
    };
    Provenance: string;
    ProvisionedAlertRule: {
      /**
       * @example {
       *   "runbook_url": "https://supercoolrunbook.com/page/13"
       * }
       */
      annotations?: { [key: string]: string };
      /** @example A */
      condition: string;
      /**
       * @example [
       *   {
       *     "datasourceUid": "__expr__",
       *     "model": {
       *       "conditions": [
       *         {
       *           "evaluator": {
       *             "params": [
       *               0,
       *               0
       *             ],
       *             "type": "gt"
       *           },
       *           "operator": {
       *             "type": "and"
       *           },
       *           "query": {
       *             "params": []
       *           },
       *           "reducer": {
       *             "params": [],
       *             "type": "avg"
       *           },
       *           "type": "query"
       *         }
       *       ],
       *       "datasource": {
       *         "type": "__expr__",
       *         "uid": "__expr__"
       *       },
       *       "expression": "1 == 1",
       *       "hide": false,
       *       "intervalMs": 1000,
       *       "maxDataPoints": 43200,
       *       "refId": "A",
       *       "type": "math"
       *     },
       *     "queryType": "",
       *     "refId": "A",
       *     "relativeTimeRange": {
       *       "from": 0,
       *       "to": 0
       *     }
       *   }
       * ]
       */
      data: components["schemas"]["AlertQuery"][];
      /** @enum {string} */
      execErrState: "OK" | "Alerting" | "Error";
      /** @example project_x */
      folderUID: string;
      for: components["schemas"]["Duration"];
      /** Format: int64 */
      id?: number;
      /** @example false */
      isPaused?: boolean;
      /**
       * @example {
       *   "team": "sre-team-1"
       * }
       */
      labels?: { [key: string]: string };
      /** @enum {string} */
      noDataState: "Alerting" | "NoData" | "OK";
      /** Format: int64 */
      orgID: number;
      provenance?: components["schemas"]["Provenance"];
      /** @example eval_group_1 */
      ruleGroup: string;
      /** @example Always firing */
      title: string;
      uid?: string;
      /** Format: date-time */
      updated?: string;
    };
    ProvisionedAlertRules: components["schemas"]["ProvisionedAlertRule"][];
    ProxyConfig: {
      /** @description NoProxy contains addresses that should not use a proxy. */
      no_proxy?: string;
      proxy_connect_header?: components["schemas"]["Header"];
      /**
       * @description ProxyFromEnvironment makes use of net/http ProxyFromEnvironment function
       * to determine proxies.
       */
      proxy_from_environment?: boolean;
      proxy_url?: components["schemas"]["URL"];
    };
    PublicDashboard: {
      accessToken?: string;
      annotationsEnabled?: boolean;
      /** Format: date-time */
      createdAt?: string;
      /** Format: int64 */
      createdBy?: number;
      dashboardUid?: string;
      isEnabled?: boolean;
      recipients?: components["schemas"]["EmailDTO"][];
      share?: components["schemas"]["ShareType"];
      timeSelectionEnabled?: boolean;
      uid?: string;
      /** Format: date-time */
      updatedAt?: string;
      /** Format: int64 */
      updatedBy?: number;
    };
    PublicDashboardDTO: {
      accessToken?: string;
      annotationsEnabled?: boolean;
      isEnabled?: boolean;
      share?: components["schemas"]["ShareType"];
      timeSelectionEnabled?: boolean;
      uid?: string;
    };
    PublicDashboardListResponse: {
      accessToken?: string;
      dashboardUid?: string;
      isEnabled?: boolean;
      slug?: string;
      title?: string;
      uid?: string;
    };
    PublicDashboardListResponseWithPagination: {
      /** Format: int64 */
      page?: number;
      /** Format: int64 */
      perPage?: number;
      publicDashboards?: components["schemas"]["PublicDashboardListResponse"][];
      /** Format: int64 */
      totalCount?: number;
    };
    /**
     * @description PublicError is derived from Error and only contains information
     * available to the end user.
     */
    PublicError: {
      extra?: { [key: string]: unknown };
      message?: string;
      messageId?: string;
      /** Format: int64 */
      statusCode?: number;
    };
    /** Format: int64 */
    PublicKeyAlgorithm: number;
    PushoverConfig: {
      device?: string;
      expire?: string;
      html?: boolean;
      http_config?: components["schemas"]["HTTPClientConfig"];
      message?: string;
      priority?: string;
      retry?: string;
      send_resolved?: boolean;
      sound?: string;
      title?: string;
      token?: components["schemas"]["Secret"];
      token_file?: string;
      ttl?: string;
      url?: string;
      url_title?: string;
      user_key?: components["schemas"]["Secret"];
      user_key_file?: string;
    };
    /**
     * QueryDataResponse contains the results from a QueryDataRequest.
     * @description It is the return type of a QueryData call.
     */
    QueryDataResponse: {
      Responses?: components["schemas"]["Responses"];
    };
    QueryHistoryDTO: {
      comment?: string;
      /** Format: int64 */
      createdAt?: number;
      /** Format: int64 */
      createdBy?: number;
      datasourceUid?: string;
      queries?: components["schemas"]["Json"];
      starred?: boolean;
      uid?: string;
    };
    /** @description QueryHistoryDeleteQueryResponse is the response struct for deleting a query from query history */
    QueryHistoryDeleteQueryResponse: {
      /** Format: int64 */
      id?: number;
      message?: string;
    };
    /** QueryHistoryPreference defines model for QueryHistoryPreference. */
    QueryHistoryPreference: {
      /** @description HomeTab one of: '' | 'query' | 'starred'; */
      homeTab?: string;
    };
    /** @description QueryHistoryResponse is a response struct for QueryHistoryDTO */
    QueryHistoryResponse: {
      result?: components["schemas"]["QueryHistoryDTO"];
    };
    QueryHistorySearchResponse: {
      result?: components["schemas"]["QueryHistorySearchResult"];
    };
    QueryHistorySearchResult: {
      /** Format: int64 */
      page?: number;
      /** Format: int64 */
      perPage?: number;
      queryHistory?: components["schemas"]["QueryHistoryDTO"][];
      /** Format: int64 */
      totalCount?: number;
    };
    /**
     * QueryStat is used for storing arbitrary statistics metadata related to a query and its result, e.g. total request time, data processing time.
     * @description The embedded FieldConfig's display name must be set.
     * It corresponds to the QueryResultMetaStat on the frontend (https://github.com/grafana/grafana/blob/master/packages/grafana-data/src/types/data.ts#L53).
     */
    QueryStat: {
      /**
       * @description Map values to a display color
       * NOTE: this interface is under development in the frontend... so simple map for now
       */
      color?: { [key: string]: unknown };
      /** @description Panel Specific Values */
      custom?: { [key: string]: unknown };
      /** Format: uint16 */
      decimals?: number;
      /** @description Description is human readable field metadata */
      description?: string;
      /** @description DisplayName overrides Grafana default naming, should not be used from a data source */
      displayName?: string;
      /** @description DisplayNameFromDS overrides Grafana default naming strategy. */
      displayNameFromDS?: string;
      /** @description Filterable indicates if the Field's data can be filtered by additional calls. */
      filterable?: boolean;
      /**
       * Format: double
       * @description Interval indicates the expected regular step between values in the series.
       * When an interval exists, consumers can identify "missing" values when the expected value is not present.
       * The grafana timeseries visualization will render disconnected values when missing values are found it the time field.
       * The interval uses the same units as the values.  For time.Time, this is defined in milliseconds.
       */
      interval?: number;
      /** @description The behavior when clicking on a result */
      links?: components["schemas"]["DataLink"][];
      mappings?: components["schemas"]["ValueMappings"];
      max?: components["schemas"]["ConfFloat64"];
      min?: components["schemas"]["ConfFloat64"];
      /** @description Alternative to empty string */
      noValue?: string;
      /**
       * @description Path is an explicit path to the field in the datasource. When the frame meta includes a path,
       * this will default to `${frame.meta.path}/${field.name}
       *
       * When defined, this value can be used as an identifier within the datasource scope, and
       * may be used as an identifier to update values in a subsequent request
       */
      path?: string;
      thresholds?: components["schemas"]["ThresholdsConfig"];
      type?: components["schemas"]["FieldTypeConfig"];
      /** @description Numeric Options */
      unit?: string;
      /** Format: double */
      value?: number;
      /** @description Writeable indicates that the datasource knows how to update this value */
      writeable?: boolean;
    };
    QuotaDTO: {
      /** Format: int64 */
      limit?: number;
      /** Format: int64 */
      org_id?: number;
      target?: string;
      /** Format: int64 */
      used?: number;
      /** Format: int64 */
      user_id?: number;
    };
    RawMessage: { [key: string]: unknown };
    /** Receiver configuration provides configuration on how to contact a receiver. */
    Receiver: {
      discord_configs?: components["schemas"]["DiscordConfig"][];
      email_configs?: components["schemas"]["EmailConfig"][];
      msteams_configs?: components["schemas"]["MSTeamsConfig"][];
      /** @description A unique identifier for this receiver. */
      name?: string;
      opsgenie_configs?: components["schemas"]["OpsGenieConfig"][];
      pagerduty_configs?: components["schemas"]["PagerdutyConfig"][];
      pushover_configs?: components["schemas"]["PushoverConfig"][];
      slack_configs?: components["schemas"]["SlackConfig"][];
      sns_configs?: components["schemas"]["SNSConfig"][];
      telegram_configs?: components["schemas"]["TelegramConfig"][];
      victorops_configs?: components["schemas"]["VictorOpsConfig"][];
      webex_configs?: components["schemas"]["WebexConfig"][];
      webhook_configs?: components["schemas"]["WebhookConfig"][];
      wechat_configs?: components["schemas"]["WechatConfig"][];
    };
    /** ReceiverExport is the provisioned file export of alerting.ReceiverV1. */
    ReceiverExport: {
      disableResolveMessage?: boolean;
      settings?: components["schemas"]["RawMessage"];
      type?: string;
      uid?: string;
    };
    /** @description RecordingRuleJSON is the external representation of a recording rule */
    RecordingRuleJSON: {
      active?: boolean;
      count?: boolean;
      description?: string;
      dest_data_source_uid?: string;
      id?: string;
      /** Format: int64 */
      interval?: number;
      name?: string;
      prom_name?: string;
      queries?: { [key: string]: unknown }[];
      /** Format: int64 */
      range?: number;
      target_ref_id?: string;
    };
    /**
     * @description RelativeTimeRange is the per query start and end time
     * for requests.
     */
    RelativeTimeRange: {
      from?: components["schemas"]["Duration"];
      to?: components["schemas"]["Duration"];
    };
    RelativeTimeRangeExport: {
      /** Format: int64 */
      from?: number;
      /** Format: int64 */
      to?: number;
    };
    /** @description ConfigDTO is model representation in transfer */
    Report: {
      /** Format: date-time */
      created?: string;
      /** Format: int64 */
      dashboardId?: number;
      dashboardName?: string;
      dashboardUid?: string;
      dashboards?: components["schemas"]["ReportDashboard"][];
      enableCsv?: boolean;
      enableDashboardUrl?: boolean;
      formats?: components["schemas"]["Type"][];
      /** Format: int64 */
      id?: number;
      message?: string;
      name?: string;
      options?: components["schemas"]["ReportOptions"];
      /** Format: int64 */
      orgId?: number;
      recipients?: string;
      replyTo?: string;
      /** Format: int64 */
      scaleFactor?: number;
      schedule?: components["schemas"]["ReportSchedule"];
      state?: components["schemas"]["State"];
      templateVars?: { [key: string]: unknown };
      /** Format: date-time */
      updated?: string;
      /** Format: int64 */
      userId?: number;
    };
    ReportBrandingOptions: {
      emailFooterLink?: string;
      emailFooterMode?: string;
      emailFooterText?: string;
      emailLogoUrl?: string;
      reportLogoUrl?: string;
    };
    ReportDashboard: {
      dashboard?: components["schemas"]["ReportDashboardID"];
      reportVariables?: { [key: string]: unknown };
      timeRange?: components["schemas"]["ReportTimeRange"];
    };
    ReportDashboardID: {
      /** Format: int64 */
      id?: number;
      name?: string;
      uid?: string;
    };
    ReportEmail: {
      email?: string;
      /** @description Comma-separated list of emails to which to send the report to. */
      emails?: string;
      /**
       * Format: int64
       * @description Send the report to the emails specified in the report. Required if emails is not present.
       */
      id?: string;
      /** @description Send the report to the emails specified in the report. Required if emails is not present. */
      useEmailsFromReport?: boolean;
    };
    ReportOptions: {
      layout?: string;
      orientation?: string;
      timeRange?: components["schemas"]["ReportTimeRange"];
    };
    ReportSchedule: {
      day?: string;
      dayOfMonth?: string;
      /** Format: date-time */
      endDate?: string;
      frequency?: string;
      /** Format: int64 */
      hour?: number;
      /** Format: int64 */
      intervalAmount?: number;
      intervalFrequency?: string;
      /** Format: int64 */
      minute?: number;
      /** Format: date-time */
      startDate?: string;
      timeZone?: string;
      workdaysOnly?: boolean;
    };
    ReportSettings: {
      branding?: components["schemas"]["ReportBrandingOptions"];
      /** Format: int64 */
      id?: number;
      /** Format: int64 */
      orgId?: number;
      /** Format: int64 */
      userId?: number;
    };
    ReportTimeRange: {
      from?: string;
      to?: string;
    };
    ResponseDetails: {
      msg?: string;
    };
    /**
     * Responses is a map of RefIDs (Unique Query ID) to DataResponses.
     * @description The QueryData method the QueryDataHandler method will set the RefId
     * property on the DataResponses' frames based on these RefIDs.
     */
    Responses: { [key: string]: components["schemas"]["DataResponse"] };
    RestoreDashboardVersionCommand: {
      /** Format: int64 */
      version?: number;
    };
    RevokeAuthTokenCmd: {
      /** Format: int64 */
      authTokenId?: number;
    };
    RoleAssignmentsDTO: {
      role_uid?: string;
      service_accounts?: number[];
      teams?: number[];
      users?: number[];
    };
    RoleDTO: {
      /** Format: date-time */
      created?: string;
      delegatable?: boolean;
      description?: string;
      displayName?: string;
      global?: boolean;
      group?: string;
      hidden?: boolean;
      name?: string;
      permissions?: components["schemas"]["Permission"][];
      uid?: string;
      /** Format: date-time */
      updated?: string;
      /** Format: int64 */
      version?: number;
    };
    RolesSearchQuery: {
      includeHidden?: boolean;
      /** Format: int64 */
      orgId?: number;
      teamIds?: number[];
      userIds?: number[];
    };
    /**
     * @description A Route is a node that contains definitions of how to handle alerts. This is modified
     * from the upstream alertmanager in that it adds the ObjectMatchers property.
     */
    Route: {
      continue?: boolean;
      group_by?: string[];
      group_interval?: string;
      group_wait?: string;
      /** @description Deprecated. Remove before v1.0 release. */
      match?: { [key: string]: string };
      match_re?: components["schemas"]["MatchRegexps"];
      matchers?: components["schemas"]["Matchers"];
      mute_time_intervals?: string[];
      object_matchers?: components["schemas"]["ObjectMatchers"];
      provenance?: components["schemas"]["Provenance"];
      receiver?: string;
      repeat_interval?: string;
      routes?: components["schemas"]["Route"][];
    };
    /**
     * @description RouteExport is the provisioned file export of definitions.Route. This is needed to hide fields that aren't useable in
     * provisioning file format. An alternative would be to define a custom MarshalJSON and MarshalYAML that excludes them.
     */
    RouteExport: {
      continue?: boolean;
      group_by?: string[];
      group_interval?: string;
      group_wait?: string;
      /** @description Deprecated. Remove before v1.0 release. */
      match?: { [key: string]: string };
      match_re?: components["schemas"]["MatchRegexps"];
      matchers?: components["schemas"]["Matchers"];
      mute_time_intervals?: string[];
      object_matchers?: components["schemas"]["ObjectMatchers"];
      receiver?: string;
      repeat_interval?: string;
      routes?: components["schemas"]["RouteExport"][];
    };
    /** @description adapted from cortex */
    Rule: {
      /** Format: double */
      evaluationTime?: number;
      health: string;
      labels?: components["schemas"]["overrideLabels"];
      lastError?: string;
      /** Format: date-time */
      lastEvaluation?: string;
      name: string;
      query: string;
      type: components["schemas"]["RuleType"];
    };
    RuleDiscovery: {
      groups: components["schemas"]["RuleGroup"][];
      totals?: { [key: string]: number };
    };
    RuleGroup: {
      /** Format: double */
      evaluationTime?: number;
      file: string;
      /** Format: double */
      interval: number;
      /** Format: date-time */
      lastEvaluation?: string;
      name: string;
      /**
       * @description In order to preserve rule ordering, while exposing type (alerting or recording)
       * specific properties, both alerting and recording rules are exposed in the
       * same array.
       */
      rules: components["schemas"]["AlertingRule"][];
      totals?: { [key: string]: number };
    };
    RuleGroupConfigResponse: {
      interval?: components["schemas"]["Duration"];
      name?: string;
      rules?: components["schemas"]["GettableExtendedRuleNode"][];
      source_tenants?: string[];
    };
    RuleResponse: {
      data?: components["schemas"]["RuleDiscovery"];
      error?: string;
      errorType?: components["schemas"]["ErrorType"];
      status: string;
    };
    /** RuleType models the type of a rule. */
    RuleType: string;
    SNSConfig: {
      api_url?: string;
      attributes?: { [key: string]: string };
      http_config?: components["schemas"]["HTTPClientConfig"];
      message?: string;
      phone_number?: string;
      send_resolved?: boolean;
      sigv4?: components["schemas"]["SigV4Config"];
      subject?: string;
      target_arn?: string;
      topic_arn?: string;
    };
    /** Sample is a single sample belonging to a metric. */
    Sample: {
      H?: components["schemas"]["FloatHistogram"];
      Metric?: components["schemas"]["Labels"];
      /** Format: int64 */
      T?: number;
      /** Format: double */
      V?: number;
    };
    SaveDashboardCommand: {
      /** Format: date-time */
      UpdatedAt?: string;
      dashboard?: components["schemas"]["Json"];
      /**
       * Format: int64
       * @description Deprecated: use FolderUID instead
       */
      folderId?: number;
      folderUid?: string;
      isFolder?: boolean;
      message?: string;
      overwrite?: boolean;
      /** Format: int64 */
      userId?: number;
    };
    SearchDeviceQueryResult: {
      devices?: components["schemas"]["DeviceSearchHitDTO"][];
      /** Format: int64 */
      page?: number;
      /** Format: int64 */
      perPage?: number;
      /** Format: int64 */
      totalCount?: number;
    };
    /** @description swagger: model */
    SearchOrgServiceAccountsResult: {
      /** Format: int64 */
      page?: number;
      /** Format: int64 */
      perPage?: number;
      serviceAccounts?: components["schemas"]["ServiceAccountDTO"][];
      /**
       * Format: int64
       * @description It can be used for pagination of the user list
       * E.g. if totalCount is equal to 100 users and
       * the perpage parameter is set to 10 then there are 10 pages of users.
       */
      totalCount?: number;
    };
    SearchOrgUsersQueryResult: {
      orgUsers?: components["schemas"]["OrgUserDTO"][];
      /** Format: int64 */
      page?: number;
      /** Format: int64 */
      perPage?: number;
      /** Format: int64 */
      totalCount?: number;
    };
    SearchResult: {
      result?: components["schemas"]["SearchResultItem"][];
    };
    SearchResultItem: {
      action?: string;
      basicRole?: string;
      /** Format: int64 */
      orgId?: number;
      roleName?: string;
      scope?: string;
      /** Format: int64 */
      teamId?: number;
      /** Format: int64 */
      userId?: number;
      /** Format: int64 */
      version?: number;
    };
    SearchTeamQueryResult: {
      /** Format: int64 */
      page?: number;
      /** Format: int64 */
      perPage?: number;
      teams?: components["schemas"]["TeamDTO"][];
      /** Format: int64 */
      totalCount?: number;
    };
    SearchUserQueryResult: {
      /** Format: int64 */
      page?: number;
      /** Format: int64 */
      perPage?: number;
      /** Format: int64 */
      totalCount?: number;
      users?: components["schemas"]["UserSearchHitDTO"][];
    };
    /** Secret special type for storing secrets. */
    Secret: string;
    SecretURL: components["schemas"]["URL"];
    /** @description swagger: model */
    ServiceAccountDTO: {
      /**
       * @example {
       *   "serviceaccounts:delete": true,
       *   "serviceaccounts:read": true,
       *   "serviceaccounts:write": true
       * }
       */
      accessControl?: { [key: string]: boolean };
      /** @example /avatar/85ec38023d90823d3e5b43ef35646af9 */
      avatarUrl?: string;
      /** Format: int64 */
      id?: number;
      /** @example false */
      isDisabled?: boolean;
      /** @example false */
      isExternal?: boolean;
      /** @example sa-grafana */
      login?: string;
      /** @example grafana */
      name?: string;
      /**
       * Format: int64
       * @example 1
       */
      orgId?: number;
      /** @example Viewer */
      role?: string;
      /**
       * Format: int64
       * @example 0
       */
      tokens?: number;
    };
    ServiceAccountProfileDTO: {
      accessControl?: { [key: string]: boolean };
      /** @example /avatar/8ea890a677d6a223c591a1beea6ea9d2 */
      avatarUrl?: string;
      /**
       * Format: date-time
       * @example 2022-03-21T14:35:33Z
       */
      createdAt?: string;
      /**
       * Format: int64
       * @example 2
       */
      id?: number;
      /** @example false */
      isDisabled?: boolean;
      /** @example false */
      isExternal?: boolean;
      /** @example sa-grafana */
      login?: string;
      /** @example test */
      name?: string;
      /**
       * Format: int64
       * @example 1
       */
      orgId?: number;
      /** @example grafana-app */
      requiredBy?: string;
      /** @example Editor */
      role?: string;
      /** @example [] */
      teams?: string[];
      /** Format: int64 */
      tokens?: number;
      /**
       * Format: date-time
       * @example 2022-03-21T14:35:33Z
       */
      updatedAt?: string;
    };
    SetResourcePermissionCommand: {
      builtInRole?: string;
      permission?: string;
      /** Format: int64 */
      teamId?: number;
      /** Format: int64 */
      userId?: number;
    };
    SetRoleAssignmentsCommand: {
      service_accounts?: number[];
      teams?: number[];
      users?: number[];
    };
    SetUserRolesCommand: {
      global?: boolean;
      includeHidden?: boolean;
      roleUids?: string[];
    };
    SettingsBag: { [key: string]: { [key: string]: string } };
    ShareType: string;
    /**
     * @description SigV4Config is the configuration for signing remote write requests with
     * AWS's SigV4 verification process. Empty values will be retrieved using the
     * AWS default credentials chain.
     */
    SigV4Config: {
      AccessKey?: string;
      Profile?: string;
      Region?: string;
      RoleARN?: string;
      SecretKey?: components["schemas"]["Secret"];
    };
    /** Format: int64 */
    SignatureAlgorithm: number;
    /**
     * SlackAction configures a single Slack action that is sent with each notification.
     * @description See https://api.slack.com/docs/message-attachments#action_fields and https://api.slack.com/docs/message-buttons
     * for more information.
     */
    SlackAction: {
      confirm?: components["schemas"]["SlackConfirmationField"];
      name?: string;
      style?: string;
      text?: string;
      type?: string;
      url?: string;
      value?: string;
    };
    /** SlackConfig configures notifications via Slack. */
    SlackConfig: {
      actions?: components["schemas"]["SlackAction"][];
      api_url?: components["schemas"]["SecretURL"];
      api_url_file?: string;
      callback_id?: string;
      /** @description Slack channel override, (like #other-channel or @username). */
      channel?: string;
      color?: string;
      fallback?: string;
      fields?: components["schemas"]["SlackField"][];
      footer?: string;
      http_config?: components["schemas"]["HTTPClientConfig"];
      icon_emoji?: string;
      icon_url?: string;
      image_url?: string;
      link_names?: boolean;
      mrkdwn_in?: string[];
      pretext?: string;
      send_resolved?: boolean;
      short_fields?: boolean;
      text?: string;
      thumb_url?: string;
      title?: string;
      title_link?: string;
      username?: string;
    };
    /**
     * @description SlackConfirmationField protect users from destructive actions or particularly distinguished decisions
     * by asking them to confirm their button click one more time.
     * See https://api.slack.com/docs/interactive-message-field-guide#confirmation_fields for more information.
     */
    SlackConfirmationField: {
      dismiss_text?: string;
      ok_text?: string;
      text?: string;
      title?: string;
    };
    /**
     * SlackField configures a single Slack field that is sent with each notification.
     * @description Each field must contain a title, value, and optionally, a boolean value to indicate if the field
     * is short enough to be displayed next to other fields designated as short.
     * See https://api.slack.com/docs/message-attachments#fields for more information.
     */
    SlackField: {
      short?: boolean;
      title?: string;
      value?: string;
    };
    SmtpNotEnabled: components["schemas"]["ResponseDetails"];
    /** A Span defines a continuous sequence of buckets. */
    Span: {
      /**
       * Format: uint32
       * @description Length of the span.
       */
      Length?: number;
      /**
       * Format: int32
       * @description Gap to previous span (always positive), or starting index for the 1st
       * span (which can be negative).
       */
      Offset?: number;
    };
    State: string;
    /** Format: int64 */
    Status: number;
    Success: components["schemas"]["ResponseDetails"];
    SuccessResponseBody: {
      message?: string;
    };
    SupportedTransformationTypes: string;
    /** SyncResult holds the result of a sync with LDAP. This gives us information on which users were updated and how. */
    SyncResult: {
      Elapsed?: components["schemas"]["Duration"];
      FailedUsers?: components["schemas"]["FailedUser"][];
      MissingUserIds?: number[];
      /** Format: date-time */
      Started?: string;
      UpdatedUserIds?: number[];
    };
    /** TLSConfig configures the options for TLS connections. */
    TLSConfig: {
      /** @description Text of the CA cert to use for the targets. */
      ca?: string;
      /** @description The CA cert to use for the targets. */
      ca_file?: string;
      /** @description Text of the client cert file for the targets. */
      cert?: string;
      /** @description The client cert file for the targets. */
      cert_file?: string;
      /** @description Disable target certificate validation. */
      insecure_skip_verify?: boolean;
      key?: components["schemas"]["Secret"];
      /** @description The client key file for the targets. */
      key_file?: string;
      max_version?: components["schemas"]["TLSVersion"];
      min_version?: components["schemas"]["TLSVersion"];
      /** @description Used to verify the hostname for the targets. */
      server_name?: string;
    };
    /** Format: uint16 */
    TLSVersion: number;
    /** TagsDTO is the frontend DTO for Tag. */
    TagsDTO: {
      /** Format: int64 */
      count?: number;
      tag?: string;
    };
    TeamDTO: {
      accessControl?: { [key: string]: boolean };
      avatarUrl?: string;
      email?: string;
      /** Format: int64 */
      id?: number;
      /** Format: int64 */
      memberCount?: number;
      name?: string;
      /** Format: int64 */
      orgId?: number;
      permission?: components["schemas"]["PermissionType"];
      uid?: string;
    };
    TeamGroupDTO: {
      groupId?: string;
      /** Format: int64 */
      orgId?: number;
      /** Format: int64 */
      teamId?: number;
    };
    TeamGroupMapping: {
      groupId?: string;
    };
    TeamMemberDTO: {
      auth_module?: string;
      avatarUrl?: string;
      email?: string;
      labels?: string[];
      login?: string;
      name?: string;
      /** Format: int64 */
      orgId?: number;
      permission?: components["schemas"]["PermissionType"];
      /** Format: int64 */
      teamId?: number;
      teamUID?: string;
      /** Format: int64 */
      userId?: number;
    };
    /** TelegramConfig configures notifications via Telegram. */
    TelegramConfig: {
      api_url?: components["schemas"]["URL"];
      /** Format: int64 */
      chat?: number;
      disable_notifications?: boolean;
      http_config?: components["schemas"]["HTTPClientConfig"];
      message?: string;
      parse_mode?: string;
      send_resolved?: boolean;
      token?: components["schemas"]["Secret"];
      token_file?: string;
    };
    TempUserDTO: {
      code?: string;
      /** Format: date-time */
      createdOn?: string;
      email?: string;
      emailSent?: boolean;
      /** Format: date-time */
      emailSentOn?: string;
      /** Format: int64 */
      id?: number;
      invitedByEmail?: string;
      invitedByLogin?: string;
      invitedByName?: string;
      name?: string;
      /** Format: int64 */
      orgId?: number;
      /** @enum {string} */
      role?: "None" | "Viewer" | "Editor" | "Admin";
      status?: components["schemas"]["TempUserStatus"];
      url?: string;
    };
    TempUserStatus: string;
    TestReceiverConfigResult: {
      error?: string;
      name?: string;
      status?: string;
      uid?: string;
    };
    TestReceiverResult: {
      grafana_managed_receiver_configs?: components["schemas"]["TestReceiverConfigResult"][];
      name?: string;
    };
    TestReceiversConfigAlertParams: {
      annotations?: components["schemas"]["LabelSet"];
      labels?: components["schemas"]["LabelSet"];
    };
    TestReceiversConfigBodyParams: {
      alert?: components["schemas"]["TestReceiversConfigAlertParams"];
      receivers?: components["schemas"]["PostableApiReceiver"][];
    };
    TestReceiversResult: {
      alert?: components["schemas"]["TestReceiversConfigAlertParams"];
      /** Format: date-time */
      notified_at?: string;
      receivers?: components["schemas"]["TestReceiverResult"][];
    };
    TestRulePayload: {
      /** @example (node_filesystem_avail_bytes{fstype!="",job="integrations/node_exporter"} node_filesystem_size_bytes{fstype!="",job="integrations/node_exporter"} * 100 < 5 and node_filesystem_readonly{fstype!="",job="integrations/node_exporter"} == 0) */
      expr?: string;
      grafana_condition?: components["schemas"]["EvalAlertConditionCommand"];
    };
    TestRuleResponse: {
      alerts?: components["schemas"]["Vector"];
      grafana_alert_instances?: components["schemas"]["AlertInstancesResponse"];
    };
    TestTemplatesConfigBodyParams: {
      /** @description Alerts to use as data when testing the template. */
      alerts?: components["schemas"]["postableAlert"][];
      /** @description Name of the template file. */
      name?: string;
      /** @description Template string to test. */
      template?: string;
    };
    TestTemplatesErrorResult: {
      /**
       * @description Kind of template error that occurred.
       * @enum {string}
       */
      kind?: "invalid_template" | "execution_error";
      /** @description Error message. */
      message?: string;
      /** @description Name of the associated template for this error. Will be empty if the Kind is "invalid_template". */
      name?: string;
    };
    TestTemplatesResult: {
      /** @description Name of the associated template definition for this result. */
      name?: string;
      /** @description Interpolated value of the template. */
      text?: string;
    };
    TestTemplatesResults: {
      errors?: components["schemas"]["TestTemplatesErrorResult"][];
      results?: components["schemas"]["TestTemplatesResult"][];
    };
    /** @description Threshold a single step on the threshold list */
    Threshold: {
      color?: string;
      state?: string;
      value?: components["schemas"]["ConfFloat64"];
    };
    /** @description ThresholdsConfig setup thresholds */
    ThresholdsConfig: {
      mode?: components["schemas"]["ThresholdsMode"];
      /** @description Must be sorted by 'value', first value is always -Infinity */
      steps?: components["schemas"]["Threshold"][];
    };
    /** @description ThresholdsMode absolute or percentage */
    ThresholdsMode: string;
    /**
     * @description TimeInterval describes intervals of time. ContainsTime will tell you if a golang time is contained
     * within the interval.
     */
    TimeInterval: {
      days_of_month?: string[];
      location?: string;
      months?: string[];
      times?: components["schemas"]["TimeRange"][];
      weekdays?: string[];
      years?: string[];
    };
    TimeIntervalItem: {
      days_of_month?: string[];
      location?: string;
      months?: string[];
      times?: components["schemas"]["TimeIntervalTimeRange"][];
      weekdays?: string[];
      years?: string[];
    };
    TimeIntervalTimeRange: {
      end_time?: string;
      start_time?: string;
    };
    /** @description Redefining this to avoid an import cycle */
    TimeRange: {
      /** Format: date-time */
      from?: string;
      /** Format: date-time */
      to?: string;
    };
    Token: {
      account?: string;
      /** Format: int64 */
      anonymousRatio?: number;
      company?: string;
      details_url?: string;
      /** Format: int64 */
      exp?: number;
      /** Format: int64 */
      iat?: number;
      /** Format: int64 */
      included_users?: number;
      iss?: string;
      jti?: string;
      /** Format: int64 */
      lexp?: number;
      /** Format: int64 */
      lic_exp_warn_days?: number;
      lid?: string;
      limit_by?: string;
      /** Format: int64 */
      max_concurrent_user_sessions?: number;
      /** Format: int64 */
      nbf?: number;
      prod?: string[];
      slug?: string;
      status?: components["schemas"]["TokenStatus"];
      sub?: string;
      /** Format: int64 */
      tok_exp_warn_days?: number;
      trial?: boolean;
      /** Format: int64 */
      trial_exp?: number;
      /** Format: int64 */
      update_days?: number;
      usage_billing?: boolean;
    };
    TokenDTO: {
      /**
       * Format: date-time
       * @example 2022-03-23T10:31:02Z
       */
      created?: string;
      /**
       * Format: date-time
       * @example 2022-03-23T10:31:02Z
       */
      expiration?: string;
      /** @example false */
      hasExpired?: boolean;
      /**
       * Format: int64
       * @example 1
       */
      id?: number;
      /** @example false */
      isRevoked?: boolean;
      /**
       * Format: date-time
       * @example 2022-03-23T10:31:02Z
       */
      lastUsedAt?: string;
      /** @example grafana */
      name?: string;
      /**
       * Format: double
       * @example 0
       */
      secondsUntilExpiration?: number;
    };
    /** Format: int64 */
    TokenStatus: number;
    Transformation: {
      expression?: string;
      field?: string;
      mapValue?: string;
      /** @enum {string} */
      type?: "regex" | "logfmt";
    };
    Transformations: components["schemas"]["Transformation"][];
    Type: string;
    /**
     * TypeMeta describes an individual object in an API response or request
     * with strings representing the type of the object and its API schema version.
     * Structures that are versioned or persisted should inline TypeMeta.
     * @description +k8s:deepcopy-gen=false
     */
    TypeMeta: {
      /**
       * @description APIVersion defines the versioned schema of this representation of an object.
       * Servers should convert recognized schemas to the latest internal value, and
       * may reject unrecognized values.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
       * +optional
       */
      apiVersion?: string;
      /**
       * @description Kind is a string value representing the REST resource this object represents.
       * Servers may infer this from the endpoint the client submits requests to.
       * Cannot be updated.
       * In CamelCase.
       * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       * +optional
       */
      kind?: string;
    };
    /**
     * A URL represents a parsed URL (technically, a URI reference).
     * @description The general form represented is:
     *
     * [scheme:][//[userinfo@]host][/]path[?query][#fragment]
     *
     * URLs that do not start with a slash after the scheme are interpreted as:
     *
     * scheme:opaque[?query][#fragment]
     *
     * Note that the Path field is stored in decoded form: /%47%6f%2f becomes /Go/.
     * A consequence is that it is impossible to tell which slashes in the Path were
     * slashes in the raw URL and which were %2f. This distinction is rarely important,
     * but when it is, the code should use the EscapedPath method, which preserves
     * the original encoding of Path.
     *
     * The RawPath field is an optional field which is only set when the default
     * encoding of Path is different from the escaped path. See the EscapedPath method
     * for more details.
     *
     * URL's String method uses the EscapedPath method to obtain the path.
     */
    URL: {
      ForceQuery?: boolean;
      Fragment?: string;
      Host?: string;
      OmitHost?: boolean;
      Opaque?: string;
      Path?: string;
      RawFragment?: string;
      RawPath?: string;
      RawQuery?: string;
      Scheme?: string;
      User?: components["schemas"]["Userinfo"];
    };
    /**
     * @description Unstructured allows objects that do not have Golang structs registered to be manipulated
     * generically.
     */
    Unstructured: {
      /**
       * @description Object is a JSON compatible map with string, float, int, bool, []interface{},
       * or map[string]interface{} children.
       */
      Object?: { [key: string]: unknown };
    };
    UpdateAlertNotificationCommand: {
      disableResolveMessage?: boolean;
      frequency?: string;
      /** Format: int64 */
      id?: number;
      isDefault?: boolean;
      name?: string;
      secureSettings?: { [key: string]: string };
      sendReminder?: boolean;
      settings?: components["schemas"]["Json"];
      type?: string;
      uid?: string;
    };
    UpdateAlertNotificationWithUidCommand: {
      disableResolveMessage?: boolean;
      frequency?: string;
      isDefault?: boolean;
      name?: string;
      secureSettings?: { [key: string]: string };
      sendReminder?: boolean;
      settings?: components["schemas"]["Json"];
      type?: string;
      uid?: string;
    };
    UpdateAnnotationsCmd: {
      data?: components["schemas"]["Json"];
      /** Format: int64 */
      id?: number;
      tags?: string[];
      text?: string;
      /** Format: int64 */
      time?: number;
      /** Format: int64 */
      timeEnd?: number;
    };
    /** @description UpdateCorrelationCommand is the command for updating a correlation */
    UpdateCorrelationCommand: {
      config?: components["schemas"]["CorrelationConfigUpdateDTO"];
      /**
       * @description Optional description of the correlation
       * @example Logs to Traces
       */
      description?: string;
      /**
       * @description Optional label identifying the correlation
       * @example My label
       */
      label?: string;
    };
    UpdateCorrelationResponseBody: {
      /** @example Correlation updated */
      message?: string;
      result?: components["schemas"]["Correlation"];
    };
    UpdateDashboardACLCommand: {
      items?: components["schemas"]["DashboardACLUpdateItem"][];
    };
    /** @description Also acts as api DTO */
    UpdateDataSourceCommand: {
      access?: components["schemas"]["DsAccess"];
      basicAuth?: boolean;
      basicAuthUser?: string;
      database?: string;
      isDefault?: boolean;
      jsonData?: components["schemas"]["Json"];
      name?: string;
      secureJsonData?: { [key: string]: string };
      type?: string;
      uid?: string;
      url?: string;
      user?: string;
      /** Format: int64 */
      version?: number;
      withCredentials?: boolean;
    };
    /**
     * @description UpdateFolderCommand captures the information required by the folder service
     * to update a folder. Use Move to update a folder's parent folder.
     */
    UpdateFolderCommand: {
      /** @description NewDescription it's an optional parameter used for overriding the existing folder description */
      description?: string;
      /** @description Overwrite only used by the legacy folder implementation */
      overwrite?: boolean;
      /** @description NewTitle it's an optional parameter used for overriding the existing folder title */
      title?: string;
      /**
       * Format: int64
       * @description Version only used by the legacy folder implementation
       */
      version?: number;
    };
    UpdateOrgAddressForm: {
      address1?: string;
      address2?: string;
      city?: string;
      country?: string;
      state?: string;
      zipcode?: string;
    };
    UpdateOrgForm: {
      name?: string;
    };
    UpdateOrgUserCommand: {
      /** @enum {string} */
      role?: "None" | "Viewer" | "Editor" | "Admin";
    };
    UpdatePlaylistCommand: {
      interval?: string;
      items?: components["schemas"]["PlaylistItem"][];
      name?: string;
      uid?: string;
    };
    UpdatePrefsCmd: {
      cookies?: components["schemas"]["CookieType"][];
      /**
       * Format: int64
       * @description The numerical :id of a favorited dashboard
       * @default 0
       */
      homeDashboardId?: number;
      homeDashboardUID?: string;
      language?: string;
      queryHistory?: components["schemas"]["QueryHistoryPreference"];
      /** @enum {string} */
      theme?: "light" | "dark" | "system";
      /** @enum {string} */
      timezone?: "utc" | "browser";
      weekStart?: string;
    };
    UpdateQuotaCmd: {
      /** Format: int64 */
      limit?: number;
      target?: string;
    };
    UpdateRoleCommand: {
      description?: string;
      displayName?: string;
      global?: boolean;
      group?: string;
      hidden?: boolean;
      name?: string;
      permissions?: components["schemas"]["Permission"][];
      /** Format: int64 */
      version?: number;
    };
    UpdateRuleGroupResponse: {
      created?: string[];
      deleted?: string[];
      message?: string;
      updated?: string[];
    };
    UpdateServiceAccountForm: {
      isDisabled?: boolean;
      name?: string;
      /** @enum {string} */
      role?: "None" | "Viewer" | "Editor" | "Admin";
      /** Format: int64 */
      serviceAccountId?: number;
    };
    UpdateTeamCommand: {
      Email?: string;
      /** Format: int64 */
      ID?: number;
      Name?: string;
    };
    UpdateTeamMemberCommand: {
      permission?: components["schemas"]["PermissionType"];
    };
    UpdateUserCommand: {
      email?: string;
      login?: string;
      name?: string;
      theme?: string;
    };
    UserLookupDTO: {
      avatarUrl?: string;
      login?: string;
      /** Format: int64 */
      userId?: number;
    };
    UserOrgDTO: {
      name?: string;
      /** Format: int64 */
      orgId?: number;
      /** @enum {string} */
      role?: "None" | "Viewer" | "Editor" | "Admin";
    };
    UserProfileDTO: {
      accessControl?: { [key: string]: boolean };
      authLabels?: string[];
      avatarUrl?: string;
      /** Format: date-time */
      createdAt?: string;
      email?: string;
      /** Format: int64 */
      id?: number;
      isDisabled?: boolean;
      isExternal?: boolean;
      isExternallySynced?: boolean;
      isGrafanaAdmin?: boolean;
      isGrafanaAdminExternallySynced?: boolean;
      login?: string;
      name?: string;
      /** Format: int64 */
      orgId?: number;
      theme?: string;
      uid?: string;
      /** Format: date-time */
      updatedAt?: string;
    };
    UserSearchHitDTO: {
      authLabels?: string[];
      avatarUrl?: string;
      email?: string;
      /** Format: int64 */
      id?: number;
      isAdmin?: boolean;
      isDisabled?: boolean;
      /** Format: date-time */
      lastSeenAt?: string;
      lastSeenAtAge?: string;
      login?: string;
      name?: string;
      uid?: string;
    };
    /** @description UserToken represents a user token */
    UserToken: {
      AuthToken?: string;
      AuthTokenSeen?: boolean;
      ClientIp?: string;
      /** Format: int64 */
      CreatedAt?: number;
      /** Format: int64 */
      Id?: number;
      PrevAuthToken?: string;
      /** Format: int64 */
      RevokedAt?: number;
      /** Format: int64 */
      RotatedAt?: number;
      /** Format: int64 */
      SeenAt?: number;
      UnhashedToken?: string;
      /** Format: int64 */
      UpdatedAt?: number;
      UserAgent?: string;
      /** Format: int64 */
      UserId?: number;
    };
    /**
     * @description The Userinfo type is an immutable encapsulation of username and
     * password details for a URL. An existing Userinfo value is guaranteed
     * to have a username set (potentially empty, as allowed by RFC 2396),
     * and optionally a password.
     */
    Userinfo: { [key: string]: unknown };
    ValidationError: {
      /** @example error message */
      msg?: string;
    };
    /** @description ValueMapping allows mapping input values to text and color */
    ValueMapping: { [key: string]: unknown };
    ValueMappings: components["schemas"]["ValueMapping"][];
    /**
     * @description Vector is basically only an alias for model.Samples, but the
     * contract is that in a Vector, all Samples have the same timestamp.
     */
    Vector: components["schemas"]["Sample"][];
    /** VictorOpsConfig configures notifications via VictorOps. */
    VictorOpsConfig: {
      api_key?: components["schemas"]["Secret"];
      api_key_file?: string;
      api_url?: components["schemas"]["URL"];
      custom_fields?: { [key: string]: string };
      entity_display_name?: string;
      http_config?: components["schemas"]["HTTPClientConfig"];
      message_type?: string;
      monitoring_tool?: string;
      routing_key?: string;
      send_resolved?: boolean;
      state_message?: string;
    };
    /** VisType is used to indicate how the data should be visualized in explore. */
    VisType: string;
    /** WebexConfig configures notifications via Webex. */
    WebexConfig: {
      api_url?: components["schemas"]["URL"];
      http_config?: components["schemas"]["HTTPClientConfig"];
      message?: string;
      room_id?: string;
      send_resolved?: boolean;
    };
    /** WebhookConfig configures notifications via a generic webhook. */
    WebhookConfig: {
      http_config?: components["schemas"]["HTTPClientConfig"];
      /**
       * Format: uint64
       * @description MaxAlerts is the maximum number of alerts to be sent per webhook message.
       * Alerts exceeding this threshold will be truncated. Setting this to 0
       * allows an unlimited number of alerts.
       */
      max_alerts?: number;
      send_resolved?: boolean;
      url?: components["schemas"]["SecretURL"];
      url_file?: string;
    };
    /** WechatConfig configures notifications via Wechat. */
    WechatConfig: {
      agent_id?: string;
      api_secret?: components["schemas"]["Secret"];
      api_url?: components["schemas"]["URL"];
      corp_id?: string;
      http_config?: components["schemas"]["HTTPClientConfig"];
      message?: string;
      message_type?: string;
      send_resolved?: boolean;
      to_party?: string;
      to_tag?: string;
      to_user?: string;
    };
    /** @description Alert alert */
    alert: {
      /**
       * Format: uri
       * @description generator URL
       * Format: uri
       */
      generatorURL?: string;
      labels: components["schemas"]["labelSet"];
    };
    alertGroup: {
      /** @description alerts */
      alerts: components["schemas"]["gettableAlert"][];
      labels: components["schemas"]["labelSet"];
      receiver: components["schemas"]["receiver"];
    };
    alertGroups: components["schemas"]["alertGroup"][];
    /** @description AlertStatus alert status */
    alertStatus: {
      /** @description inhibited by */
      inhibitedBy: string[];
      /** @description silenced by */
      silencedBy: string[];
      /**
       * @description state
       * @enum {string}
       */
      state: "[unprocessed active suppressed]";
    };
    /** @description AlertmanagerConfig alertmanager config */
    alertmanagerConfig: {
      /** @description original */
      original: string;
    };
    /** @description AlertmanagerStatus alertmanager status */
    alertmanagerStatus: {
      cluster: components["schemas"]["clusterStatus"];
      config: components["schemas"]["alertmanagerConfig"];
      /**
       * Format: date-time
       * @description uptime
       */
      uptime: string;
      versionInfo: components["schemas"]["versionInfo"];
    };
    /** @description ClusterStatus cluster status */
    clusterStatus: {
      /** @description name */
      name?: string;
      /** @description peers */
      peers?: components["schemas"]["peerStatus"][];
      /**
       * @description status
       * @enum {string}
       */
      status: "[ready settling disabled]";
    };
    deviceDTO: {
      avatarUrl?: string;
      clientIp?: string;
      /** Format: date-time */
      createdAt?: string;
      deviceId?: string;
      lastSeenAt?: string;
      /** Format: date-time */
      updatedAt?: string;
      userAgent?: string;
    };
    gettableAlert: {
      annotations: components["schemas"]["labelSet"];
      /**
       * Format: date-time
       * @description ends at
       */
      endsAt: string;
      /** @description fingerprint */
      fingerprint: string;
      /**
       * Format: uri
       * @description generator URL
       * Format: uri
       */
      generatorURL?: string;
      labels: components["schemas"]["labelSet"];
      /** @description receivers */
      receivers: components["schemas"]["receiver"][];
      /**
       * Format: date-time
       * @description starts at
       */
      startsAt: string;
      status: components["schemas"]["alertStatus"];
      /**
       * Format: date-time
       * @description updated at
       */
      updatedAt: string;
    };
    /** @description GettableAlerts gettable alerts */
    gettableAlerts: components["schemas"]["gettableAlert"][];
    gettableSilence: {
      /** @description comment */
      comment: string;
      /** @description created by */
      createdBy: string;
      /**
       * Format: date-time
       * @description ends at
       */
      endsAt: string;
      /** @description id */
      id: string;
      matchers: components["schemas"]["matchers"];
      /**
       * Format: date-time
       * @description starts at
       */
      startsAt: string;
      status: components["schemas"]["silenceStatus"];
      /**
       * Format: date-time
       * @description updated at
       */
      updatedAt: string;
    };
    /** @description GettableSilences gettable silences */
    gettableSilences: components["schemas"]["gettableSilence"][];
    /** @description Integration integration */
    integration: {
      /**
       * Format: date-time
       * @description A timestamp indicating the last attempt to deliver a notification regardless of the outcome.
       * Format: date-time
       */
      lastNotifyAttempt?: string;
      /** @description Duration of the last attempt to deliver a notification in humanized format (`1s` or `15ms`, etc). */
      lastNotifyAttemptDuration?: string;
      /** @description Error string for the last attempt to deliver a notification. Empty if the last attempt was successful. */
      lastNotifyAttemptError?: string;
      /** @description name */
      name: string;
      /** @description send resolved */
      sendResolved: boolean;
    };
    /** @description LabelSet label set */
    labelSet: { [key: string]: string };
    /** @description Matcher matcher */
    matcher: {
      /** @description is equal */
      isEqual?: boolean;
      /** @description is regex */
      isRegex: boolean;
      /** @description name */
      name: string;
      /** @description value */
      value: string;
    };
    /** @description Matchers matchers */
    matchers: components["schemas"]["matcher"][];
    /**
     * override the labels type with a map for generation.
     * @description The custom marshaling for labels.Labels ends up doing this anyways.
     */
    overrideLabels: { [key: string]: string };
    /** @description PeerStatus peer status */
    peerStatus: {
      /** @description address */
      address: string;
      /** @description name */
      name: string;
    };
    postSilencesOKBody: {
      /** @description silence ID */
      silenceID?: string;
    };
    /** @description PostableAlert postable alert */
    postableAlert: {
      annotations?: components["schemas"]["labelSet"];
      /**
       * Format: date-time
       * @description ends at
       * Format: date-time
       */
      endsAt?: string;
      /**
       * Format: uri
       * @description generator URL
       * Format: uri
       */
      generatorURL?: string;
      labels: components["schemas"]["labelSet"];
      /**
       * Format: date-time
       * @description starts at
       * Format: date-time
       */
      startsAt?: string;
    };
    /** @description PostableAlerts postable alerts */
    postableAlerts: components["schemas"]["postableAlert"][];
    postableSilence: {
      /** @description comment */
      comment: string;
      /** @description created by */
      createdBy: string;
      /**
       * Format: date-time
       * @description ends at
       */
      endsAt: string;
      /** @description id */
      id?: string;
      matchers: components["schemas"]["matchers"];
      /**
       * Format: date-time
       * @description starts at
       */
      startsAt: string;
    };
    /**
     * @description PublicError is derived from Error and only contains information
     * available to the end user.
     */
    publicError: {
      /** @description Extra Additional information about the error */
      extra?: { [key: string]: unknown };
      /** @description Message A human readable message */
      message?: string;
      /** @description MessageID A unique identifier for the error */
      messageId: string;
      /**
       * Format: int64
       * @description StatusCode The HTTP status code returned
       */
      statusCode: number;
    };
    receiver: {
      /** @description active */
      active: boolean;
      /** @description integrations */
      integrations: components["schemas"]["integration"][];
      /** @description name */
      name: string;
    };
    resourcePermissionDTO: {
      actions?: string[];
      builtInRole?: string;
      /** Format: int64 */
      id?: number;
      isInherited?: boolean;
      isManaged?: boolean;
      isServiceAccount?: boolean;
      permission?: string;
      roleName?: string;
      team?: string;
      teamAvatarUrl?: string;
      /** Format: int64 */
      teamId?: number;
      userAvatarUrl?: string;
      /** Format: int64 */
      userId?: number;
      userLogin?: string;
    };
    setPermissionCommand: {
      permission?: string;
    };
    setPermissionsCommand: {
      permissions?: components["schemas"]["SetResourcePermissionCommand"][];
    };
    /** @description Silence silence */
    silence: {
      /** @description comment */
      comment: string;
      /** @description created by */
      createdBy: string;
      /**
       * Format: date-time
       * @description ends at
       */
      endsAt: string;
      matchers: components["schemas"]["matchers"];
      /**
       * Format: date-time
       * @description starts at
       */
      startsAt: string;
    };
    /** @description SilenceStatus silence status */
    silenceStatus: {
      /**
       * @description state
       * @enum {string}
       */
      state: "[expired active pending]";
    };
    /** @description VersionInfo version info */
    versionInfo: {
      /** @description branch */
      branch: string;
      /** @description build date */
      buildDate: string;
      /** @description build user */
      buildUser: string;
      /** @description go version */
      goVersion: string;
      /** @description revision */
      revision: string;
      /** @description version */
      version: string;
    };
  };
  responses: {
    /** (empty) */
    GetAllIntervalsResponse: {
      content: {
        "application/json": components["schemas"]["GettableTimeIntervals"][];
      };
    };
    /** (empty) */
    GetIntervalsByNameResponse: {
      content: {
        "application/json": components["schemas"]["GettableTimeIntervals"];
      };
    };
    /** (empty) */
    GetReceiverResponse: {
      content: {
        "application/json": components["schemas"]["GettableApiReceiver"];
      };
    };
    /** (empty) */
    GetReceiversResponse: {
      content: {
        "application/json": components["schemas"]["GettableApiReceiver"][];
      };
    };
    /** (empty) */
    GettableHistoricUserConfigs: {
      content: {
        "application/json": components["schemas"]["GettableHistoricUserConfig"][];
      };
    };
    /** (empty) */
    SMTPNotEnabledError: unknown;
    /** (empty) */
    StateHistory: {
      content: {
        "application/json": components["schemas"]["Frame"];
      };
    };
    /** (empty) */
    TestGrafanaRuleResponse: {
      content: {
        "application/json": components["schemas"]["postableAlert"][];
      };
    };
    /** AcceptedResponse */
    acceptedResponse: {
      content: {
        "application/json": components["schemas"]["ErrorResponseBody"];
      };
    };
    /** (empty) */
    adminCreateUserResponse: {
      content: {
        "application/json": components["schemas"]["AdminCreateUserResponse"];
      };
    };
    /** (empty) */
    adminGetSettingsResponse: {
      content: {
        "application/json": components["schemas"]["SettingsBag"];
      };
    };
    /** (empty) */
    adminGetStatsResponse: {
      content: {
        "application/json": components["schemas"]["AdminStats"];
      };
    };
    /** (empty) */
    adminGetUserAuthTokensResponse: {
      content: {
        "application/json": components["schemas"]["UserToken"][];
      };
    };
    /** BadRequestError is returned when the request is invalid and it cannot be processed. */
    badRequestError: {
      content: {
        "application/json": components["schemas"]["ErrorResponseBody"];
      };
    };
    /** BadRequestPublicError is returned when the request is invalid and it cannot be processed. */
    badRequestPublicError: {
      content: {
        "application/json": components["schemas"]["publicError"];
      };
    };
    /** (empty) */
    calculateDashboardDiffResponse: {
      content: {
        "application/json": number[];
      };
    };
    /** ConflictError */
    conflictError: {
      content: {
        "application/json": components["schemas"]["ErrorResponseBody"];
      };
    };
    /** (empty) */
    contentResponse: {
      content: {
        "application/json": number[];
      };
    };
    /** (empty) */
    createCorrelationResponse: {
      content: {
        "application/json": components["schemas"]["CreateCorrelationResponseBody"];
      };
    };
    /** (empty) */
    createDashboardSnapshotResponse: {
      content: {
        "application/json": {
          /** @description Unique key used to delete the snapshot. It is different from the key so that only the creator can delete the snapshot. */
          deleteKey?: string;
          deleteUrl?: string;
          /**
           * Format: int64
           * @description Snapshot id
           */
          id?: number;
          /** @description Unique key */
          key?: string;
          url?: string;
        };
      };
    };
    /** (empty) */
    createOrUpdateDatasourceResponse: {
      content: {
        "application/json": {
          datasource: components["schemas"]["DataSource"];
          /**
           * Format: int64
           * @description ID Identifier of the new data source.
           * @example 65
           */
          id: number;
          /**
           * @description Message Message of the deleted dashboard.
           * @example Data source added
           */
          message: string;
          /**
           * @description Name of the new data source.
           * @example My Data source
           */
          name: string;
        };
      };
    };
    /** (empty) */
    createOrgResponse: {
      content: {
        "application/json": {
          /**
           * @description Message Message of the created org.
           * @example Data source added
           */
          message: string;
          /**
           * Format: int64
           * @description ID Identifier of the created org.
           * @example 65
           */
          orgId: number;
        };
      };
    };
    /** (empty) */
    createPlaylistResponse: {
      content: {
        "application/json": components["schemas"]["Playlist"];
      };
    };
    /** (empty) */
    createPublicDashboardResponse: {
      content: {
        "application/json": components["schemas"]["PublicDashboard"];
      };
    };
    /** (empty) */
    createReportResponse: {
      content: {
        "application/json": {
          /** Format: int64 */
          id?: number;
          message?: string;
        };
      };
    };
    /** (empty) */
    createRoleResponse: {
      content: {
        "application/json": components["schemas"]["RoleDTO"];
      };
    };
    /** (empty) */
    createServiceAccountResponse: {
      content: {
        "application/json": components["schemas"]["ServiceAccountDTO"];
      };
    };
    /** (empty) */
    createTeamResponse: {
      content: {
        "application/json": {
          message?: string;
          /** Format: int64 */
          teamId?: number;
        };
      };
    };
    /** (empty) */
    createTokenResponse: {
      content: {
        "application/json": components["schemas"]["NewApiKeyResult"];
      };
    };
    /** (empty) */
    dashboardResponse: {
      content: {
        "application/json": components["schemas"]["DashboardFullWithMeta"];
      };
    };
    /** (empty) */
    dashboardVersionResponse: {
      content: {
        "application/json": components["schemas"]["DashboardVersionMeta"];
      };
    };
    /** (empty) */
    dashboardVersionsResponse: {
      content: {
        "application/json": components["schemas"]["DashboardVersionMeta"][];
      };
    };
    /** (empty) */
    deleteAlertNotificationChannelResponse: {
      content: {
        "application/json": {
          /**
           * Format: int64
           * @description ID Identifier of the deleted notification channel.
           * @example 65
           */
          id: number;
          /** @description Message Message of the deleted notificatiton channel. */
          message: string;
        };
      };
    };
    /** (empty) */
    deleteCorrelationResponse: {
      content: {
        "application/json": components["schemas"]["DeleteCorrelationResponseBody"];
      };
    };
    /** (empty) */
    deleteDashboardResponse: {
      content: {
        "application/json": {
          /**
           * Format: int64
           * @description ID Identifier of the deleted dashboard.
           * @example 65
           */
          id: number;
          /**
           * @description Message Message of the deleted dashboard.
           * @example Dashboard My Dashboard deleted
           */
          message: string;
          /**
           * @description Title Title of the deleted dashboard.
           * @example My Dashboard
           */
          title: string;
        };
      };
    };
    /** (empty) */
    deleteDataSourceByNameResponse: {
      content: {
        "application/json": {
          /**
           * Format: int64
           * @description ID Identifier of the deleted data source.
           * @example 65
           */
          id: number;
          /**
           * @description Message Message of the deleted dashboard.
           * @example Dashboard My Dashboard deleted
           */
          message: string;
        };
      };
    };
    /** (empty) */
    deleteFolderResponse: {
      content: {
        "application/json": {
          /**
           * Format: int64
           * @description ID Identifier of the deleted folder.
           * @example 65
           */
          id: number;
          /**
           * @description Message Message of the deleted folder.
           * @example Folder My Folder deleted
           */
          message: string;
          /**
           * @description Title of the deleted folder.
           * @example My Folder
           */
          title: string;
        };
      };
    };
    /** (empty) */
    devicesResponse: {
      content: {
        "application/json": components["schemas"]["deviceDTO"][];
      };
    };
    /** (empty) */
    devicesSearchResponse: {
      content: {
        "application/json": components["schemas"]["SearchDeviceQueryResult"];
      };
    };
    /** (empty) */
    folderResponse: {
      content: {
        "application/json": components["schemas"]["Folder"];
      };
    };
    /** ForbiddenError is returned if the user/token has insufficient permissions to access the requested resource. */
    forbiddenError: {
      content: {
        "application/json": components["schemas"]["ErrorResponseBody"];
      };
    };
    /** ForbiddenPublicError is returned if the user/token has insufficient permissions to access the requested resource. */
    forbiddenPublicError: {
      content: {
        "application/json": components["schemas"]["publicError"];
      };
    };
    /**
     * A GenericError is the default error message that is generated.
     * For certain status codes there are more appropriate error structures.
     */
    genericError: {
      content: {
        "application/json": components["schemas"]["ErrorResponseBody"];
      };
    };
    /** (empty) */
    getAPIkeyResponse: {
      content: {
        "application/json": components["schemas"]["ApiKeyDTO"][];
      };
    };
    /** (empty) */
    getAccessControlStatusResponse: {
      content: {
        "application/json": components["schemas"]["Status"];
      };
    };
    /** (empty) */
    getAlertNotificationChannelResponse: {
      content: {
        "application/json": components["schemas"]["AlertNotification"];
      };
    };
    /** (empty) */
    getAlertNotificationChannelsResponse: {
      content: {
        "application/json": components["schemas"]["AlertNotification"][];
      };
    };
    /** (empty) */
    getAlertNotificationLookupResponse: {
      content: {
        "application/json": components["schemas"]["AlertNotificationLookup"][];
      };
    };
    /** (empty) */
    getAlertResponse: {
      content: {
        "application/json": components["schemas"]["LegacyAlert"];
      };
    };
    /** (empty) */
    getAlertsResponse: {
      content: {
        "application/json": components["schemas"]["AlertListItemDTO"][];
      };
    };
    /** (empty) */
    getAllRolesResponse: {
      content: {
        "application/json": components["schemas"]["RoleDTO"][];
      };
    };
    /** (empty) */
    getAnnotationByIDResponse: {
      content: {
        "application/json": components["schemas"]["Annotation"];
      };
    };
    /** (empty) */
    getAnnotationTagsResponse: {
      content: {
        "application/json": components["schemas"]["GetAnnotationTagsResponse"];
      };
    };
    /** (empty) */
    getAnnotationsResponse: {
      content: {
        "application/json": components["schemas"]["Annotation"][];
      };
    };
    /** (empty) */
    getCorrelationResponse: {
      content: {
        "application/json": components["schemas"]["Correlation"];
      };
    };
    /** (empty) */
    getCorrelationsBySourceUIDResponse: {
      content: {
        "application/json": components["schemas"]["Correlation"][];
      };
    };
    /** (empty) */
    getCorrelationsResponse: {
      content: {
        "application/json": components["schemas"]["Correlation"][];
      };
    };
    /** (empty) */
    getCurrentOrgResponse: {
      content: {
        "application/json": components["schemas"]["OrgDetailsDTO"];
      };
    };
    /** (empty) */
    getDashboardPermissionsListResponse: {
      content: {
        "application/json": components["schemas"]["DashboardACLInfoDTO"][];
      };
    };
    /** (empty) */
    getDashboardSnapshotResponse: unknown;
    /** (empty) */
    getDashboardStatesResponse: {
      content: {
        "application/json": components["schemas"]["AlertStateInfoDTO"][];
      };
    };
    /** (empty) */
    getDashboardsTagsResponse: {
      content: {
        "application/json": components["schemas"]["DashboardTagCloudItem"][];
      };
    };
    /** (empty) */
    getDataSourceIDResponse: {
      content: {
        "application/json": {
          /**
           * Format: int64
           * @description ID Identifier of the data source.
           * @example 65
           */
          id: number;
        };
      };
    };
    /** (empty) */
    getDataSourceResponse: {
      content: {
        "application/json": components["schemas"]["DataSource"];
      };
    };
    /** (empty) */
    getDataSourcesResponse: {
      content: {
        "application/json": components["schemas"]["DataSourceList"];
      };
    };
    /** (empty) */
    getFolderDescendantCountsResponse: {
      content: {
        "application/json": components["schemas"]["DescendantCounts"];
      };
    };
    /** (empty) */
    getFolderPermissionListResponse: {
      content: {
        "application/json": components["schemas"]["DashboardACLInfoDTO"][];
      };
    };
    /** (empty) */
    getFoldersResponse: {
      content: {
        "application/json": components["schemas"]["FolderSearchHit"][];
      };
    };
    /** (empty) */
    getHomeDashboardResponse: {
      content: {
        "application/json": components["schemas"]["GetHomeDashboardResponse"];
      };
    };
    /** (empty) */
    getLibraryElementArrayResponse: {
      content: {
        "application/json": components["schemas"]["LibraryElementArrayResponse"];
      };
    };
    /** (empty) */
    getLibraryElementConnectionsResponse: {
      content: {
        "application/json": components["schemas"]["LibraryElementConnectionsResponse"];
      };
    };
    /** (empty) */
    getLibraryElementResponse: {
      content: {
        "application/json": components["schemas"]["LibraryElementResponse"];
      };
    };
    /** (empty) */
    getLibraryElementsResponse: {
      content: {
        "application/json": components["schemas"]["LibraryElementSearchResponse"];
      };
    };
    /** (empty) */
    getLicenseTokenResponse: {
      content: {
        "application/json": components["schemas"]["Token"];
      };
    };
    /** (empty) */
    getOrgByIDResponse: {
      content: {
        "application/json": components["schemas"]["OrgDetailsDTO"];
      };
    };
    /** (empty) */
    getOrgByNameResponse: {
      content: {
        "application/json": components["schemas"]["OrgDetailsDTO"];
      };
    };
    /** (empty) */
    getOrgUsersForCurrentOrgLookupResponse: {
      content: {
        "application/json": components["schemas"]["UserLookupDTO"][];
      };
    };
    /** (empty) */
    getOrgUsersForCurrentOrgResponse: {
      content: {
        "application/json": components["schemas"]["OrgUserDTO"][];
      };
    };
    /** (empty) */
    getOrgUsersResponse: {
      content: {
        "application/json": components["schemas"]["OrgUserDTO"][];
      };
    };
    /** (empty) */
    getPendingOrgInvitesResponse: {
      content: {
        "application/json": components["schemas"]["TempUserDTO"][];
      };
    };
    /** (empty) */
    getPlaylistDashboardsResponse: {
      content: {
        "application/json": components["schemas"]["PlaylistDashboardsSlice"];
      };
    };
    /** (empty) */
    getPlaylistItemsResponse: {
      content: {
        "application/json": components["schemas"]["PlaylistItemDTO"][];
      };
    };
    /** (empty) */
    getPlaylistResponse: {
      content: {
        "application/json": components["schemas"]["PlaylistDTO"];
      };
    };
    /** (empty) */
    getPreferencesResponse: {
      content: {
        "application/json": components["schemas"]["Preferences"];
      };
    };
    /** (empty) */
    getPublicAnnotationsResponse: {
      content: {
        "application/json": components["schemas"]["AnnotationEvent"][];
      };
    };
    /** (empty) */
    getPublicDashboardResponse: {
      content: {
        "application/json": components["schemas"]["PublicDashboard"];
      };
    };
    /** (empty) */
    getQueryHistoryDeleteQueryResponse: {
      content: {
        "application/json": components["schemas"]["QueryHistoryDeleteQueryResponse"];
      };
    };
    /** (empty) */
    getQueryHistoryResponse: {
      content: {
        "application/json": components["schemas"]["QueryHistoryResponse"];
      };
    };
    /** (empty) */
    getQueryHistorySearchResponse: {
      content: {
        "application/json": components["schemas"]["QueryHistorySearchResponse"];
      };
    };
    /** (empty) */
    getQuotaResponse: {
      content: {
        "application/json": components["schemas"]["QuotaDTO"][];
      };
    };
    /** (empty) */
    getReportResponse: {
      content: {
        "application/json": components["schemas"]["Report"];
      };
    };
    /** (empty) */
    getReportSettingsResponse: {
      content: {
        "application/json": components["schemas"]["ReportSettings"];
      };
    };
    /** (empty) */
    getReportsResponse: {
      content: {
        "application/json": components["schemas"]["Report"][];
      };
    };
    /** (empty) */
    getResourcePermissionsResponse: {
      content: {
        "application/json": components["schemas"]["resourcePermissionDTO"][];
      };
    };
    /** (empty) */
    getRoleAssignmentsResponse: {
      content: {
        "application/json": components["schemas"]["RoleAssignmentsDTO"];
      };
    };
    /** (empty) */
    getRoleResponse: {
      content: {
        "application/json": components["schemas"]["RoleDTO"];
      };
    };
    /** (empty) */
    getSSOSettingsResponse: {
      content: {
        "application/json": {
          id?: string;
          provider?: string;
          settings?: { [key: string]: unknown };
          source?: string;
        };
      };
    };
    /** (empty) */
    getSharingOptionsResponse: {
      content: {
        "application/json": {
          externalEnabled?: boolean;
          externalSnapshotName?: string;
          externalSnapshotURL?: string;
        };
      };
    };
    /** (empty) */
    getSignedInUserOrgListResponse: {
      content: {
        "application/json": components["schemas"]["UserOrgDTO"][];
      };
    };
    /** (empty) */
    getSignedInUserTeamListResponse: {
      content: {
        "application/json": components["schemas"]["TeamDTO"][];
      };
    };
    /** (empty) */
    getStatusResponse: unknown;
    /** (empty) */
    getSyncStatusResponse: {
      content: {
        "application/json": components["schemas"]["ActiveSyncStatusDTO"];
      };
    };
    /** (empty) */
    getTeamByIDResponse: {
      content: {
        "application/json": components["schemas"]["TeamDTO"];
      };
    };
    /** (empty) */
    getTeamGroupsApiResponse: {
      content: {
        "application/json": components["schemas"]["TeamGroupDTO"][];
      };
    };
    /** (empty) */
    getTeamMembersResponse: {
      content: {
        "application/json": components["schemas"]["TeamMemberDTO"][];
      };
    };
    /** (empty) */
    getUserAuthTokensResponse: {
      content: {
        "application/json": components["schemas"]["UserToken"][];
      };
    };
    /** (empty) */
    getUserOrgListResponse: {
      content: {
        "application/json": components["schemas"]["UserOrgDTO"][];
      };
    };
    /** (empty) */
    getUserTeamsResponse: {
      content: {
        "application/json": components["schemas"]["TeamDTO"][];
      };
    };
    /** (empty) */
    helpFlagResponse: {
      content: {
        "application/json": {
          /** Format: int64 */
          helpFlags1?: number;
          message?: string;
        };
      };
    };
    /** (empty) */
    importDashboardResponse: {
      content: {
        "application/json": components["schemas"]["ImportDashboardResponse"];
      };
    };
    /** InternalServerError is a general error indicating something went wrong internally. */
    internalServerError: {
      content: {
        "application/json": components["schemas"]["ErrorResponseBody"];
      };
    };
    /** InternalServerPublicError is a general error indicating something went wrong internally. */
    internalServerPublicError: {
      content: {
        "application/json": components["schemas"]["publicError"];
      };
    };
    /** (empty) */
    jwksResponse: {
      content: {
        "application/json": {
          keys?: components["schemas"]["JSONWebKey"][];
        };
      };
    };
    /** (empty) */
    listBuiltinRolesResponse: {
      content: {
        "application/json": {
          [key: string]: components["schemas"]["RoleDTO"][];
        };
      };
    };
    /** (empty) */
    listPublicDashboardsResponse: {
      content: {
        "application/json": components["schemas"]["PublicDashboardListResponseWithPagination"];
      };
    };
    /** (empty) */
    listRecordingRulesResponse: {
      content: {
        "application/json": components["schemas"]["RecordingRuleJSON"][];
      };
    };
    /** (empty) */
    listRolesResponse: {
      content: {
        "application/json": components["schemas"]["RoleDTO"][];
      };
    };
    /** (empty) */
    listSSOSettingsResponse: {
      content: {
        "application/json": {
          id?: string;
          provider?: string;
          settings?: { [key: string]: unknown };
          source?: string;
        }[];
      };
    };
    /** (empty) */
    listSortOptionsResponse: {
      content: {
        "application/json": {
          description?: string;
          displayName?: string;
          meta?: string;
          name?: string;
        };
      };
    };
    /** (empty) */
    listTeamsRolesResponse: {
      content: {
        "application/json": {
          [key: string]: components["schemas"]["RoleDTO"][];
        };
      };
    };
    /** (empty) */
    listTokensResponse: {
      content: {
        "application/json": components["schemas"]["TokenDTO"][];
      };
    };
    /** (empty) */
    listUsersRolesResponse: {
      content: {
        "application/json": {
          [key: string]: components["schemas"]["RoleDTO"][];
        };
      };
    };
    /** NotFoundError is returned when the requested resource was not found. */
    notFoundError: {
      content: {
        "application/json": components["schemas"]["ErrorResponseBody"];
      };
    };
    /** NotFoundPublicError is returned when the requested resource was not found. */
    notFoundPublicError: {
      content: {
        "application/json": components["schemas"]["publicError"];
      };
    };
    /** An OKResponse is returned if the request was successful. */
    okResponse: {
      content: {
        "application/json": components["schemas"]["SuccessResponseBody"];
      };
    };
    /** (empty) */
    pauseAlertResponse: {
      content: {
        "application/json": {
          /** Format: int64 */
          alertId: number;
          message: string;
          /**
           * @description Alert result state
           * required true
           */
          state?: string;
        };
      };
    };
    /** (empty) */
    pauseAlertsResponse: {
      content: {
        "application/json": {
          /**
           * Format: int64
           * @description AlertsAffected is the number of the affected alerts.
           */
          alertsAffected: number;
          message: string;
          /**
           * @description Alert result state
           * required true
           */
          state?: string;
        };
      };
    };
    /** (empty) */
    postAPIkeyResponse: {
      content: {
        "application/json": components["schemas"]["NewApiKeyResult"];
      };
    };
    /** (empty) */
    postAnnotationResponse: {
      content: {
        "application/json": {
          /**
           * Format: int64
           * @description ID Identifier of the created annotation.
           * @example 65
           */
          id: number;
          /** @description Message Message of the created annotation. */
          message: string;
        };
      };
    };
    /** (empty) */
    postDashboardResponse: {
      content: {
        "application/json": {
          /** @description FolderUID The unique identifier (uid) of the folder the dashboard belongs to. */
          folderUid?: string;
          /**
           * Format: int64
           * @description ID The unique identifier (id) of the created/updated dashboard.
           * @example 1
           */
          id: number;
          /**
           * @description Status status of the response.
           * @example success
           */
          status: string;
          /**
           * @description Slug The slug of the dashboard.
           * @example my-dashboard
           */
          title: string;
          /**
           * @description UID The unique identifier (uid) of the created/updated dashboard.
           * @example nHz3SXiiz
           */
          uid: string;
          /**
           * @description URL The relative URL for accessing the created/updated dashboard.
           * @example /d/nHz3SXiiz/my-dashboard
           */
          url: string;
          /**
           * Format: int64
           * @description Version The version of the dashboard.
           * @example 2
           */
          version: number;
        };
      };
    };
    /** (empty) */
    postRenewLicenseTokenResponse: unknown;
    /** PreconditionFailedError */
    preconditionFailedError: {
      content: {
        "application/json": components["schemas"]["ErrorResponseBody"];
      };
    };
    /** (empty) */
    publicErrorResponse: {
      content: {
        "application/json": components["schemas"]["publicError"];
      };
    };
    /** (empty) */
    queryMetricsWithExpressionsRespons: {
      content: {
        "application/json": components["schemas"]["QueryDataResponse"];
      };
    };
    /** (empty) */
    queryPublicDashboardResponse: {
      content: {
        "application/json": components["schemas"]["QueryDataResponse"];
      };
    };
    /** (empty) */
    receiversResponse: {
      content: {
        "application/json": components["schemas"]["receiver"][];
      };
    };
    /** (empty) */
    recordingRuleResponse: {
      content: {
        "application/json": components["schemas"]["RecordingRuleJSON"];
      };
    };
    /** (empty) */
    recordingRuleWriteTargetResponse: {
      content: {
        "application/json": components["schemas"]["PrometheusRemoteWriteTargetJSON"];
      };
    };
    /** (empty) */
    refreshLicenseStatsResponse: {
      content: {
        "application/json": components["schemas"]["ActiveUserStats"];
      };
    };
    /** (empty) */
    resourcePermissionsDescription: {
      content: {
        "application/json": components["schemas"]["Description"];
      };
    };
    /** (empty) */
    retrieveServiceAccountResponse: {
      content: {
        "application/json": components["schemas"]["ServiceAccountDTO"];
      };
    };
    /** (empty) */
    searchDashboardSnapshotsResponse: {
      content: {
        "application/json": components["schemas"]["DashboardSnapshotDTO"][];
      };
    };
    /** (empty) */
    searchOrgServiceAccountsWithPagingResponse: {
      content: {
        "application/json": components["schemas"]["SearchOrgServiceAccountsResult"];
      };
    };
    /** (empty) */
    searchOrgUsersResponse: {
      content: {
        "application/json": components["schemas"]["SearchOrgUsersQueryResult"];
      };
    };
    /** (empty) */
    searchOrgsResponse: {
      content: {
        "application/json": components["schemas"]["OrgDTO"][];
      };
    };
    /** (empty) */
    searchPlaylistsResponse: {
      content: {
        "application/json": components["schemas"]["Playlists"];
      };
    };
    /** (empty) */
    searchResponse: {
      content: {
        "application/json": components["schemas"]["HitList"];
      };
    };
    /** (empty) */
    searchResultResponse: {
      content: {
        "application/json": components["schemas"]["SearchResult"];
      };
    };
    /** (empty) */
    searchTeamsResponse: {
      content: {
        "application/json": components["schemas"]["SearchTeamQueryResult"];
      };
    };
    /** (empty) */
    searchUsersResponse: {
      content: {
        "application/json": components["schemas"]["UserSearchHitDTO"][];
      };
    };
    /** (empty) */
    searchUsersWithPagingResponse: {
      content: {
        "application/json": components["schemas"]["SearchUserQueryResult"];
      };
    };
    /** (empty) */
    setRoleAssignmentsResponse: {
      content: {
        "application/json": components["schemas"]["RoleAssignmentsDTO"];
      };
    };
    /** (empty) */
    testAlertResponse: {
      content: {
        "application/json": components["schemas"]["AlertTestResult"];
      };
    };
    /** UnauthorizedError is returned when the request is not authenticated. */
    unauthorisedError: {
      content: {
        "application/json": components["schemas"]["ErrorResponseBody"];
      };
    };
    /** UnauthorisedPublicError is returned when the request is not authenticated. */
    unauthorisedPublicError: {
      content: {
        "application/json": components["schemas"]["publicError"];
      };
    };
    /** UnprocessableEntityError */
    unprocessableEntityError: {
      content: {
        "application/json": components["schemas"]["ErrorResponseBody"];
      };
    };
    /** (empty) */
    updateCorrelationResponse: {
      content: {
        "application/json": components["schemas"]["UpdateCorrelationResponseBody"];
      };
    };
    /** (empty) */
    updatePlaylistResponse: {
      content: {
        "application/json": components["schemas"]["PlaylistDTO"];
      };
    };
    /** (empty) */
    updatePublicDashboardResponse: {
      content: {
        "application/json": components["schemas"]["PublicDashboard"];
      };
    };
    /** (empty) */
    updateServiceAccountResponse: {
      content: {
        "application/json": {
          /** Format: int64 */
          id?: number;
          message?: string;
          name?: string;
          serviceaccount?: components["schemas"]["ServiceAccountProfileDTO"];
        };
      };
    };
    /** (empty) */
    userResponse: {
      content: {
        "application/json": components["schemas"]["UserProfileDTO"];
      };
    };
    /** (empty) */
    viewPublicDashboardResponse: {
      content: {
        "application/json": components["schemas"]["DashboardFullWithMeta"];
      };
    };
  };
}

export interface operations {
  /**
   * Returns the result of the search through access-control role assignments.
   *
   * You need to have a permission with action `teams.roles:read` on scope `teams:*`
   * and a permission with action `users.roles:read` on scope `users:*`.
   */
  searchResult: {
    responses: {
      200: components["responses"]["searchResultResponse"];
      400: components["responses"]["badRequestError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * Gets all existing roles. The response contains all global and organization local roles, for the organization which user is signed in.
   *
   * You need to have a permission with action `roles:read` and scope `roles:*`.
   */
  listRoles: {
    parameters: {
      query: {
        delegatable?: boolean;
      };
    };
    responses: {
      200: components["responses"]["listRolesResponse"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * Creates a new custom role and maps given permissions to that role. Note that roles with the same prefix as Fixed Roles can’t be created.
   *
   * You need to have a permission with action `roles:write` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only create custom roles with the same, or a subset of permissions which the user has.
   * For example, if a user does not have required permissions for creating users, they won’t be able to create a custom role which allows to do that. This is done to prevent escalation of privileges.
   */
  createRole: {
    responses: {
      201: components["responses"]["createRoleResponse"];
      400: components["responses"]["badRequestError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateRoleForm"];
      };
    };
  };
  /**
   * Get a role for the given UID.
   *
   * You need to have a permission with action `roles:read` and scope `roles:*`.
   */
  getRole: {
    parameters: {
      path: {
        roleUID: string;
      };
    };
    responses: {
      200: components["responses"]["getRoleResponse"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** You need to have a permission with action `roles:write` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only create custom roles with the same, or a subset of permissions which the user has. */
  updateRole: {
    parameters: {
      path: {
        roleUID: string;
      };
    };
    responses: {
      200: components["responses"]["getRoleResponse"];
      400: components["responses"]["badRequestError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateRoleCommand"];
      };
    };
  };
  /**
   * Delete a role with the given UID, and it’s permissions. If the role is assigned to a built-in role, the deletion operation will fail, unless force query param is set to true, and in that case all assignments will also be deleted.
   *
   * You need to have a permission with action `roles:delete` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only delete a custom role with the same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to delete a custom role which allows to do that.
   */
  deleteRole: {
    parameters: {
      query: {
        force?: boolean;
        global?: boolean;
      };
      path: {
        roleUID: string;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * Get role assignments for the role with the given UID.
   *
   * You need to have a permission with action `teams.roles:list` and scope `teams:id:*` and `users.roles:list` and scope `users:id:*`.
   */
  getRoleAssignments: {
    parameters: {
      path: {
        roleUID: string;
      };
    };
    responses: {
      200: components["responses"]["getRoleAssignmentsResponse"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * Set role assignments for the role with the given UID.
   *
   * You need to have a permission with action `teams.roles:add` and `teams.roles:remove` and scope `permissions:type:delegate`, and `users.roles:add` and `users.roles:remove` and scope `permissions:type:delegate`.
   */
  setRoleAssignments: {
    parameters: {
      path: {
        roleUID: string;
      };
    };
    responses: {
      200: components["responses"]["setRoleAssignmentsResponse"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SetRoleAssignmentsCommand"];
      };
    };
  };
  /**
   * Returns an indicator to check if fine-grained access control is enabled or not.
   *
   * You need to have a permission with action `status:accesscontrol` and scope `services:accesscontrol`.
   */
  getAccessControlStatus: {
    responses: {
      200: components["responses"]["getAccessControlStatusResponse"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * Lists the roles that have been directly assigned to the given teams.
   *
   * You need to have a permission with action `teams.roles:read` and scope `teams:id:*`.
   */
  listTeamsRoles: {
    responses: {
      200: components["responses"]["listTeamsRolesResponse"];
      400: components["responses"]["badRequestError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["RolesSearchQuery"];
      };
    };
  };
  /** You need to have a permission with action `teams.roles:read` and scope `teams:id:<team ID>`. */
  listTeamRoles: {
    parameters: {
      path: {
        teamId: number;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** You need to have a permission with action `teams.roles:add` and `teams.roles:remove` and scope `permissions:type:delegate` for each. */
  setTeamRoles: {
    parameters: {
      path: {
        teamId: number;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** You need to have a permission with action `teams.roles:add` and scope `permissions:type:delegate`. */
  addTeamRole: {
    parameters: {
      path: {
        teamId: number;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AddTeamRoleCommand"];
      };
    };
  };
  /** You need to have a permission with action `teams.roles:remove` and scope `permissions:type:delegate`. */
  removeTeamRole: {
    parameters: {
      path: {
        roleUID: string;
        teamId: number;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * Lists the roles that have been directly assigned to the given users. The list does not include built-in roles (Viewer, Editor, Admin or Grafana Admin), and it does not include roles that have been inherited from a team.
   *
   * You need to have a permission with action `users.roles:read` and scope `users:id:*`.
   */
  listUsersRoles: {
    responses: {
      200: components["responses"]["listUsersRolesResponse"];
      400: components["responses"]["badRequestError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["RolesSearchQuery"];
      };
    };
  };
  /**
   * Lists the roles that have been directly assigned to a given user. The list does not include built-in roles (Viewer, Editor, Admin or Grafana Admin), and it does not include roles that have been inherited from a team.
   *
   * You need to have a permission with action `users.roles:read` and scope `users:id:<user ID>`.
   */
  listUserRoles: {
    parameters: {
      path: {
        userId: number;
      };
    };
    responses: {
      200: components["responses"]["getAllRolesResponse"];
      400: components["responses"]["badRequestError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * Update the user’s role assignments to match the provided set of UIDs. This will remove any assigned roles that aren’t in the request and add roles that are in the set but are not already assigned to the user.
   * If you want to add or remove a single role, consider using Add a user role assignment or Remove a user role assignment instead.
   *
   * You need to have a permission with action `users.roles:add` and `users.roles:remove` and scope `permissions:type:delegate` for each. `permissions:type:delegate`  scope ensures that users can only assign or unassign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to assign or unassign a role which will allow to do that. This is done to prevent escalation of privileges.
   */
  setUserRoles: {
    parameters: {
      path: {
        userId: number;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SetUserRolesCommand"];
      };
    };
  };
  /**
   * Assign a role to a specific user. For bulk updates consider Set user role assignments.
   *
   * You need to have a permission with action `users.roles:add` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only assign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to assign a role which will allow to do that. This is done to prevent escalation of privileges.
   */
  addUserRole: {
    parameters: {
      path: {
        userId: number;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AddUserRoleCommand"];
      };
    };
  };
  /**
   * Revoke a role from a user. For bulk updates consider Set user role assignments.
   *
   * You need to have a permission with action `users.roles:remove` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only unassign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to unassign a role which will allow to do that. This is done to prevent escalation of privileges.
   */
  removeUserRole: {
    parameters: {
      query: {
        /** A flag indicating if the assignment is global or not. If set to false, the default org ID of the authenticated user will be used from the request to remove assignment. */
        global?: boolean;
      };
      path: {
        roleUID: string;
        userId: number;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  getResourceDescription: {
    parameters: {
      path: {
        resource: string;
      };
    };
    responses: {
      200: components["responses"]["resourcePermissionsDescription"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  getResourcePermissions: {
    parameters: {
      path: {
        resource: string;
        resourceID: string;
      };
    };
    responses: {
      200: components["responses"]["getResourcePermissionsResponse"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * Assigns permissions for a resource by a given type (`:resource`) and `:resourceID` to one or many
   * assignment types. Allowed resources are `datasources`, `teams`, `dashboards`, `folders`, and `serviceaccounts`.
   * Refer to the `/access-control/{resource}/description` endpoint for allowed Permissions.
   */
  setResourcePermissions: {
    parameters: {
      path: {
        resource: string;
        resourceID: string;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["setPermissionsCommand"];
      };
    };
  };
  /**
   * Assigns permissions for a resource by a given type (`:resource`) and `:resourceID` to a built-in role.
   * Allowed resources are `datasources`, `teams`, `dashboards`, `folders`, and `serviceaccounts`.
   * Refer to the `/access-control/{resource}/description` endpoint for allowed Permissions.
   */
  setResourcePermissionsForBuiltInRole: {
    parameters: {
      path: {
        resource: string;
        resourceID: string;
        builtInRole: string;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["setPermissionCommand"];
      };
    };
  };
  /**
   * Assigns permissions for a resource by a given type (`:resource`) and `:resourceID` to a team.
   * Allowed resources are `datasources`, `teams`, `dashboards`, `folders`, and `serviceaccounts`.
   * Refer to the `/access-control/{resource}/description` endpoint for allowed Permissions.
   */
  setResourcePermissionsForTeam: {
    parameters: {
      path: {
        resource: string;
        resourceID: string;
        teamID: number;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["setPermissionCommand"];
      };
    };
  };
  /**
   * Assigns permissions for a resource by a given type (`:resource`) and `:resourceID` to a user or a service account.
   * Allowed resources are `datasources`, `teams`, `dashboards`, `folders`, and `serviceaccounts`.
   * Refer to the `/access-control/{resource}/description` endpoint for allowed Permissions.
   */
  setResourcePermissionsForUser: {
    parameters: {
      path: {
        resource: string;
        resourceID: string;
        userID: number;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["setPermissionCommand"];
      };
    };
  };
  /** You need to have a permission with action `ldap.status:read`. */
  getSyncStatus: {
    responses: {
      200: components["responses"]["getSyncStatusResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `ldap.config:reload`. */
  reloadLDAPCfg: {
    responses: {
      200: components["responses"]["okResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `ldap.status:read`. */
  getLDAPStatus: {
    responses: {
      200: components["responses"]["okResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `ldap.user:sync`. */
  postSyncUserWithLDAP: {
    parameters: {
      path: {
        user_id: number;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `ldap.user:read`. */
  getUserFromLDAP: {
    parameters: {
      path: {
        user_name: string;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  pauseAllAlerts: {
    responses: {
      200: components["responses"]["pauseAlertsResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PauseAllAlertsCommand"];
      };
    };
  };
  adminProvisioningReloadAccessControl: {
    responses: {
      202: components["responses"]["acceptedResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
    };
  };
  /**
   * Reloads the provisioning config files for dashboards again. It won’t return until the new provisioned entities are already stored in the database. In case of dashboards, it will stop polling for changes in dashboard files and then restart it with new configurations after returning.
   * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `provisioning:reload` and scope `provisioners:dashboards`.
   */
  adminProvisioningReloadDashboards: {
    responses: {
      200: components["responses"]["okResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * Reloads the provisioning config files for datasources again. It won’t return until the new provisioned entities are already stored in the database. In case of dashboards, it will stop polling for changes in dashboard files and then restart it with new configurations after returning.
   * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `provisioning:reload` and scope `provisioners:datasources`.
   */
  adminProvisioningReloadDatasources: {
    responses: {
      200: components["responses"]["okResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * Reloads the provisioning config files for legacy alert notifiers again. It won’t return until the new provisioned entities are already stored in the database. In case of dashboards, it will stop polling for changes in dashboard files and then restart it with new configurations after returning.
   * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `provisioning:reload` and scope `provisioners:notifications`.
   */
  adminProvisioningReloadNotifications: {
    responses: {
      200: components["responses"]["okResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * Reloads the provisioning config files for plugins again. It won’t return until the new provisioned entities are already stored in the database. In case of dashboards, it will stop polling for changes in dashboard files and then restart it with new configurations after returning.
   * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `provisioning:reload` and scope `provisioners:plugin`.
   */
  adminProvisioningReloadPlugins: {
    responses: {
      200: components["responses"]["okResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `settings:read` and scopes: `settings:*`, `settings:auth.saml:` and `settings:auth.saml:enabled` (property level). */
  adminGetSettings: {
    responses: {
      200: components["responses"]["adminGetSettingsResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
    };
  };
  /**
   * Only works with Basic Authentication (username and password). See introduction for an explanation.
   * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `server:stats:read`.
   */
  adminGetStats: {
    responses: {
      200: components["responses"]["adminGetStatsResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users:create`.
   * Note that OrgId is an optional parameter that can be used to assign a new user to a different organization when `auto_assign_org` is set to `true`.
   */
  adminCreateUser: {
    responses: {
      200: components["responses"]["adminCreateUserResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      412: components["responses"]["preconditionFailedError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AdminCreateUserForm"];
      };
    };
  };
  /** If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users:delete` and scope `global.users:*`. */
  adminDeleteUser: {
    parameters: {
      path: {
        user_id: number;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.authtoken:list` and scope `global.users:*`. */
  adminGetUserAuthTokens: {
    parameters: {
      path: {
        user_id: number;
      };
    };
    responses: {
      200: components["responses"]["adminGetUserAuthTokensResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users:disable` and scope `global.users:1` (userIDScope). */
  adminDisableUser: {
    parameters: {
      path: {
        user_id: number;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users:enable` and scope `global.users:1` (userIDScope). */
  adminEnableUser: {
    parameters: {
      path: {
        user_id: number;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.logout` and scope `global.users:*`. */
  adminLogoutUser: {
    parameters: {
      path: {
        user_id: number;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.password:update` and scope `global.users:*`. */
  adminUpdateUserPassword: {
    parameters: {
      path: {
        user_id: number;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AdminUpdateUserPasswordForm"];
      };
    };
  };
  /**
   * Only works with Basic Authentication (username and password). See introduction for an explanation.
   * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.permissions:update` and scope `global.users:*`.
   */
  adminUpdateUserPermissions: {
    parameters: {
      path: {
        user_id: number;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AdminUpdateUserPermissionsForm"];
      };
    };
  };
  /** If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.quotas:list` and scope `global.users:1` (userIDScope). */
  getUserQuota: {
    parameters: {
      path: {
        user_id: number;
      };
    };
    responses: {
      200: components["responses"]["getQuotaResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.quotas:update` and scope `global.users:1` (userIDScope). */
  updateUserQuota: {
    parameters: {
      path: {
        quota_target: string;
        user_id: number;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateQuotaCmd"];
      };
    };
  };
  /**
   * Revokes the given auth token (device) for the user. User of issued auth token (device) will no longer be logged in and will be required to authenticate again upon next activity.
   * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.authtoken:update` and scope `global.users:*`.
   */
  adminRevokeUserAuthToken: {
    parameters: {
      path: {
        user_id: number;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["RevokeAuthTokenCmd"];
      };
    };
  };
  /** Returns all notification channels that the authenticated user has permission to view. */
  getAlertNotificationChannels: {
    responses: {
      200: components["responses"]["getAlertNotificationChannelsResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** You can find the full list of [supported notifiers](https://grafana.com/docs/grafana/latest/alerting/old-alerting/notifications/#list-of-supported-notifiers) on the alert notifiers page. */
  createAlertNotificationChannel: {
    responses: {
      200: components["responses"]["getAlertNotificationChannelResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      409: components["responses"]["conflictError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateAlertNotificationCommand"];
      };
    };
  };
  /** Returns all notification channels, but with less detailed information. Accessible by any authenticated user and is mainly used by providing alert notification channels in Grafana UI when configuring alert rule. */
  getAlertNotificationLookup: {
    responses: {
      200: components["responses"]["getAlertNotificationLookupResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** Sends a test notification to the channel. */
  notificationChannelTest: {
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      412: components["responses"]["SMTPNotEnabledError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["NotificationTestCommand"];
      };
    };
  };
  /** Returns the notification channel given the notification channel UID. */
  getAlertNotificationChannelByUID: {
    parameters: {
      path: {
        notification_channel_uid: string;
      };
    };
    responses: {
      200: components["responses"]["getAlertNotificationChannelResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** Updates an existing notification channel identified by uid. */
  updateAlertNotificationChannelByUID: {
    parameters: {
      path: {
        notification_channel_uid: string;
      };
    };
    responses: {
      200: components["responses"]["getAlertNotificationChannelResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateAlertNotificationWithUidCommand"];
      };
    };
  };
  /** Deletes an existing notification channel identified by UID. */
  deleteAlertNotificationChannelByUID: {
    parameters: {
      path: {
        notification_channel_uid: string;
      };
    };
    responses: {
      200: components["responses"]["deleteAlertNotificationChannelResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** Returns the notification channel given the notification channel ID. */
  getAlertNotificationChannelByID: {
    parameters: {
      path: {
        notification_channel_id: number;
      };
    };
    responses: {
      200: components["responses"]["getAlertNotificationChannelResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** Updates an existing notification channel identified by ID. */
  updateAlertNotificationChannel: {
    parameters: {
      path: {
        notification_channel_id: number;
      };
    };
    responses: {
      200: components["responses"]["getAlertNotificationChannelResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateAlertNotificationCommand"];
      };
    };
  };
  /** Deletes an existing notification channel identified by ID. */
  deleteAlertNotificationChannel: {
    parameters: {
      path: {
        notification_channel_id: number;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  getAlerts: {
    parameters: {
      query: {
        /** Limit response to alerts in specified dashboard(s). You can specify multiple dashboards. */
        dashboardId?: string[];
        /** Limit response to alert for a specified panel on a dashboard. */
        panelId?: number;
        /** Limit response to alerts having a name like this value. */
        query?: string;
        /** Return alerts with one or more of the following alert states */
        state?:
          | "all"
          | "no_data"
          | "paused"
          | "alerting"
          | "ok"
          | "pending"
          | "unknown";
        /** Limit response to X number of alerts. */
        limit?: number;
        /** Limit response to alerts of dashboards in specified folder(s). You can specify multiple folders */
        folderId?: string[];
        /** Limit response to alerts having a dashboard name like this value./ Limit response to alerts having a dashboard name like this value. */
        dashboardQuery?: string;
        /** Limit response to alerts of dashboards with specified tags. To do an “AND” filtering with multiple tags, specify the tags parameter multiple times */
        dashboardTag?: string[];
      };
    };
    responses: {
      200: components["responses"]["getAlertsResponse"];
      401: components["responses"]["unauthorisedError"];
      500: components["responses"]["internalServerError"];
    };
  };
  getDashboardStates: {
    parameters: {
      query: {
        dashboardId: number;
      };
    };
    responses: {
      200: components["responses"]["getDashboardStatesResponse"];
      400: components["responses"]["badRequestError"];
      500: components["responses"]["internalServerError"];
    };
  };
  testAlert: {
    responses: {
      200: components["responses"]["testAlertResponse"];
      400: components["responses"]["badRequestError"];
      403: components["responses"]["forbiddenError"];
      422: components["responses"]["unprocessableEntityError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AlertTestCommand"];
      };
    };
  };
  /**
   * “evalMatches” data in the response is cached in the db when and only when the state of the alert changes (e.g. transitioning from “ok” to “alerting” state).
   * If data from one server triggers the alert first and, before that server is seen leaving alerting state, a second server also enters a state that would trigger the alert, the second server will not be visible in “evalMatches” data.
   */
  getAlertByID: {
    parameters: {
      path: {
        alert_id: string;
      };
    };
    responses: {
      200: components["responses"]["getAlertResponse"];
      401: components["responses"]["unauthorisedError"];
      500: components["responses"]["internalServerError"];
    };
  };
  pauseAlert: {
    parameters: {
      path: {
        alert_id: string;
      };
    };
    responses: {
      200: components["responses"]["pauseAlertResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PauseAlertCommand"];
      };
    };
  };
  /** Starting in Grafana v6.4 regions annotations are now returned in one entity that now includes the timeEnd property. */
  getAnnotations: {
    parameters: {
      query: {
        /** Find annotations created after specific epoch datetime in milliseconds. */
        from?: number;
        /** Find annotations created before specific epoch datetime in milliseconds. */
        to?: number;
        /** Limit response to annotations created by specific user. */
        userId?: number;
        /** Find annotations for a specified alert. */
        alertId?: number;
        /** Find annotations that are scoped to a specific dashboard */
        dashboardId?: number;
        /** Find annotations that are scoped to a specific dashboard */
        dashboardUID?: string;
        /** Find annotations that are scoped to a specific panel */
        panelId?: number;
        /** Max limit for results returned. */
        limit?: number;
        /** Use this to filter organization annotations. Organization annotations are annotations from an annotation data source that are not connected specifically to a dashboard or panel. You can filter by multiple tags. */
        tags?: string[];
        /** Return alerts or user created annotations */
        type?: "alert" | "annotation";
        /** Match any or all tags */
        matchAny?: boolean;
      };
    };
    responses: {
      200: components["responses"]["getAnnotationsResponse"];
      401: components["responses"]["unauthorisedError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * Creates an annotation in the Grafana database. The dashboardId and panelId fields are optional. If they are not specified then an organization annotation is created and can be queried in any dashboard that adds the Grafana annotations data source. When creating a region annotation include the timeEnd property.
   * The format for `time` and `timeEnd` should be epoch numbers in millisecond resolution.
   * The response for this HTTP request is slightly different in versions prior to v6.4. In prior versions you would also get an endId if you where creating a region. But in 6.4 regions are represented using a single event with time and timeEnd properties.
   */
  postAnnotation: {
    responses: {
      200: components["responses"]["postAnnotationResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PostAnnotationsCmd"];
      };
    };
  };
  /** Creates an annotation by using Graphite-compatible event format. The `when` and `data` fields are optional. If `when` is not specified then the current time will be used as annotation’s timestamp. The `tags` field can also be in prior to Graphite `0.10.0` format (string with multiple tags being separated by a space). */
  postGraphiteAnnotation: {
    responses: {
      200: components["responses"]["postAnnotationResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PostGraphiteAnnotationsCmd"];
      };
    };
  };
  massDeleteAnnotations: {
    responses: {
      200: components["responses"]["okResponse"];
      401: components["responses"]["unauthorisedError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["MassDeleteAnnotationsCmd"];
      };
    };
  };
  /** Find all the event tags created in the annotations. */
  getAnnotationTags: {
    parameters: {
      query: {
        /** Tag is a string that you can use to filter tags. */
        tag?: string;
        /** Max limit for results returned. */
        limit?: string;
      };
    };
    responses: {
      200: components["responses"]["getAnnotationTagsResponse"];
      401: components["responses"]["unauthorisedError"];
      500: components["responses"]["internalServerError"];
    };
  };
  getAnnotationByID: {
    parameters: {
      path: {
        annotation_id: string;
      };
    };
    responses: {
      200: components["responses"]["getAnnotationByIDResponse"];
      401: components["responses"]["unauthorisedError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** Updates all properties of an annotation that matches the specified id. To only update certain property, consider using the Patch Annotation operation. */
  updateAnnotation: {
    parameters: {
      path: {
        annotation_id: string;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateAnnotationsCmd"];
      };
    };
  };
  /** Deletes the annotation that matches the specified ID. */
  deleteAnnotationByID: {
    parameters: {
      path: {
        annotation_id: string;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * Updates one or more properties of an annotation that matches the specified ID.
   * This operation currently supports updating of the `text`, `tags`, `time` and `timeEnd` properties.
   * This is available in Grafana 6.0.0-beta2 and above.
   */
  patchAnnotation: {
    parameters: {
      path: {
        annotation_id: string;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PatchAnnotationsCmd"];
      };
    };
  };
  /**
   * Will return auth keys.
   *
   * Deprecated: true.
   *
   * Deprecated. Please use GET /api/serviceaccounts and GET /api/serviceaccounts/{id}/tokens instead
   * see https://grafana.com/docs/grafana/next/administration/api-keys/#migrate-api-keys-to-grafana-service-accounts-using-the-api.
   */
  getAPIkeys: {
    parameters: {
      query: {
        /** Show expired keys */
        includeExpired?: boolean;
      };
    };
    responses: {
      200: components["responses"]["getAPIkeyResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** Will return details of the created API key. */
  addAPIkey: {
    responses: {
      200: components["responses"]["postAPIkeyResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      409: components["responses"]["conflictError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AddAPIKeyCommand"];
      };
    };
  };
  /**
   * Deletes an API key.
   * Deprecated. See: https://grafana.com/docs/grafana/next/administration/api-keys/#migrate-api-keys-to-grafana-service-accounts-using-the-api.
   */
  deleteAPIkey: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  searchDashboardSnapshots: {
    parameters: {
      query: {
        /** Search Query */
        query?: string;
        /** Limit the number of returned results */
        limit?: number;
      };
    };
    responses: {
      200: components["responses"]["searchDashboardSnapshotsResponse"];
      500: components["responses"]["internalServerError"];
    };
  };
  calculateDashboardDiff: {
    responses: {
      200: components["responses"]["calculateDashboardDiffResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": {
          base?: components["schemas"]["CalculateDiffTarget"];
          /**
           * @description The type of diff to return
           * Description:
           * `basic`
           * `json`
           * @enum {string}
           */
          diffType?: "basic" | "json";
          new?: components["schemas"]["CalculateDiffTarget"];
        };
      };
    };
  };
  /**
   * Creates a new dashboard or updates an existing dashboard.
   * Note: This endpoint is not intended for creating folders, use `POST /api/folders` for that.
   */
  postDashboard: {
    responses: {
      200: components["responses"]["postDashboardResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      412: components["responses"]["preconditionFailedError"];
      422: components["responses"]["unprocessableEntityError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SaveDashboardCommand"];
      };
    };
  };
  getHomeDashboard: {
    responses: {
      200: components["responses"]["getHomeDashboardResponse"];
      401: components["responses"]["unauthorisedError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** Please refer to [updated API](#/dashboard_permissions/getDashboardPermissionsListByUID) instead */
  getDashboardPermissionsListByID: {
    parameters: {
      path: {
        DashboardID: number;
      };
    };
    responses: {
      200: components["responses"]["getDashboardPermissionsListResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * Please refer to [updated API](#/dashboard_permissions/updateDashboardPermissionsByUID) instead
   *
   * This operation will remove existing permissions if they’re not included in the request.
   */
  updateDashboardPermissionsByID: {
    parameters: {
      path: {
        DashboardID: number;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateDashboardACLCommand"];
      };
    };
  };
  /** Please refer to [updated API](#/dashboard_versions/restoreDashboardVersionByUID) instead */
  restoreDashboardVersionByID: {
    parameters: {
      path: {
        DashboardID: number;
      };
    };
    responses: {
      200: components["responses"]["postDashboardResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["RestoreDashboardVersionCommand"];
      };
    };
  };
  /** Please refer to [updated API](#/dashboard_versions/getDashboardVersionsByUID) instead */
  getDashboardVersionsByID: {
    parameters: {
      path: {
        DashboardID: number;
      };
    };
    responses: {
      200: components["responses"]["dashboardVersionsResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** Please refer to [updated API](#/dashboard_versions/getDashboardVersionByUID) instead */
  getDashboardVersionByID: {
    parameters: {
      path: {
        DashboardID: number;
        DashboardVersionID: number;
      };
    };
    responses: {
      200: components["responses"]["dashboardVersionResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  importDashboard: {
    responses: {
      200: components["responses"]["importDashboardResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      412: components["responses"]["preconditionFailedError"];
      422: components["responses"]["unprocessableEntityError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ImportDashboardRequest"];
      };
    };
  };
  /** Get list of public dashboards */
  listPublicDashboards: {
    responses: {
      200: components["responses"]["listPublicDashboardsResponse"];
      401: components["responses"]["unauthorisedPublicError"];
      403: components["responses"]["forbiddenPublicError"];
      500: components["responses"]["internalServerPublicError"];
    };
  };
  getDashboardTags: {
    responses: {
      200: components["responses"]["getDashboardsTagsResponse"];
      401: components["responses"]["unauthorisedError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** Get public dashboard by dashboardUid */
  getPublicDashboard: {
    parameters: {
      path: {
        dashboardUid: string;
      };
    };
    responses: {
      200: components["responses"]["getPublicDashboardResponse"];
      400: components["responses"]["badRequestPublicError"];
      401: components["responses"]["unauthorisedPublicError"];
      403: components["responses"]["forbiddenPublicError"];
      404: components["responses"]["notFoundPublicError"];
      500: components["responses"]["internalServerPublicError"];
    };
  };
  /** Create public dashboard for a dashboard */
  createPublicDashboard: {
    parameters: {
      path: {
        dashboardUid: string;
      };
    };
    responses: {
      200: components["responses"]["createPublicDashboardResponse"];
      400: components["responses"]["badRequestPublicError"];
      401: components["responses"]["unauthorisedPublicError"];
      403: components["responses"]["forbiddenPublicError"];
      500: components["responses"]["internalServerPublicError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PublicDashboardDTO"];
      };
    };
  };
  /** Delete public dashboard for a dashboard */
  deletePublicDashboard: {
    parameters: {
      path: {
        dashboardUid: string;
        uid: string;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestPublicError"];
      401: components["responses"]["unauthorisedPublicError"];
      403: components["responses"]["forbiddenPublicError"];
      500: components["responses"]["internalServerPublicError"];
    };
  };
  /** Update public dashboard for a dashboard */
  updatePublicDashboard: {
    parameters: {
      path: {
        dashboardUid: string;
        uid: string;
      };
    };
    responses: {
      200: components["responses"]["updatePublicDashboardResponse"];
      400: components["responses"]["badRequestPublicError"];
      401: components["responses"]["unauthorisedPublicError"];
      403: components["responses"]["forbiddenPublicError"];
      500: components["responses"]["internalServerPublicError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PublicDashboardDTO"];
      };
    };
  };
  /** Will return the dashboard given the dashboard unique identifier (uid). */
  getDashboardByUID: {
    parameters: {
      path: {
        uid: string;
      };
    };
    responses: {
      200: components["responses"]["dashboardResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** Will delete the dashboard given the specified unique identifier (uid). */
  deleteDashboardByUID: {
    parameters: {
      path: {
        uid: string;
      };
    };
    responses: {
      200: components["responses"]["deleteDashboardResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  getDashboardPermissionsListByUID: {
    parameters: {
      path: {
        uid: string;
      };
    };
    responses: {
      200: components["responses"]["getDashboardPermissionsListResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** This operation will remove existing permissions if they’re not included in the request. */
  updateDashboardPermissionsByUID: {
    parameters: {
      path: {
        uid: string;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateDashboardACLCommand"];
      };
    };
  };
  restoreDashboardVersionByUID: {
    parameters: {
      path: {
        uid: string;
      };
    };
    responses: {
      200: components["responses"]["postDashboardResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["RestoreDashboardVersionCommand"];
      };
    };
  };
  getDashboardVersionsByUID: {
    parameters: {
      path: {
        uid: string;
      };
      query: {
        /** Maximum number of results to return */
        limit?: number;
        /** Version to start from when returning queries */
        start?: number;
      };
    };
    responses: {
      200: components["responses"]["dashboardVersionsResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  getDashboardVersionByUID: {
    parameters: {
      path: {
        DashboardVersionID: number;
        uid: string;
      };
    };
    responses: {
      200: components["responses"]["dashboardVersionResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled
   * you need to have a permission with action: `datasources:read` and scope: `datasources:*`.
   */
  getDataSources: {
    responses: {
      200: components["responses"]["getDataSourcesResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * By defining `password` and `basicAuthPassword` under secureJsonData property
   * Grafana encrypts them securely as an encrypted blob in the database.
   * The response then lists the encrypted fields under secureJsonFields.
   *
   * If you are running Grafana Enterprise and have Fine-grained access control enabled
   * you need to have a permission with action: `datasources:create`
   */
  addDataSource: {
    responses: {
      200: components["responses"]["createOrUpdateDatasourceResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      409: components["responses"]["conflictError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AddDataSourceCommand"];
      };
    };
  };
  getCorrelations: {
    parameters: {
      query: {
        /** Limit the maximum number of correlations to return per page */
        limit?: number;
        /** Page index for starting fetching correlations */
        page?: number;
        /** Source datasource UID filter to be applied to correlations */
        sourceUID?: string[];
      };
    };
    responses: {
      200: components["responses"]["getCorrelationsResponse"];
      401: components["responses"]["unauthorisedError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled
   * you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:name:*` and `datasources:name:test_datasource` (single data source).
   */
  getDataSourceIdByName: {
    parameters: {
      path: {
        name: string;
      };
    };
    responses: {
      200: components["responses"]["getDataSourceIDResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled
   * you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:name:*` and `datasources:name:test_datasource` (single data source).
   */
  getDataSourceByName: {
    parameters: {
      path: {
        name: string;
      };
    };
    responses: {
      200: components["responses"]["getDataSourceResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled
   * you need to have a permission with action: `datasources:delete` and scopes: `datasources:*`, `datasources:name:*` and `datasources:name:test_datasource` (single data source).
   */
  deleteDataSourceByName: {
    parameters: {
      path: {
        name: string;
      };
    };
    responses: {
      200: components["responses"]["deleteDataSourceByNameResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** Proxies all calls to the actual data source. */
  datasourceProxyGETByUIDcalls: {
    parameters: {
      path: {
        datasource_proxy_route: string;
        uid: string;
      };
    };
    responses: {
      /** (empty) */
      200: unknown;
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** Proxies all calls to the actual data source. The data source should support POST methods for the specific path and role as defined */
  datasourceProxyPOSTByUIDcalls: {
    parameters: {
      path: {
        datasource_proxy_route: string;
        uid: string;
      };
    };
    responses: {
      /** (empty) */
      201: unknown;
      /** (empty) */
      202: unknown;
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": unknown;
      };
    };
  };
  /** Proxies all calls to the actual data source. */
  datasourceProxyDELETEByUIDcalls: {
    parameters: {
      path: {
        uid: string;
        datasource_proxy_route: string;
      };
    };
    responses: {
      /** (empty) */
      202: unknown;
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * Proxies all calls to the actual data source.
   *
   * Please refer to [updated API](#/datasources/datasourceProxyGETByUIDcalls) instead
   */
  datasourceProxyGETcalls: {
    parameters: {
      path: {
        datasource_proxy_route: string;
        id: string;
      };
    };
    responses: {
      /** (empty) */
      200: unknown;
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * Proxies all calls to the actual data source. The data source should support POST methods for the specific path and role as defined
   *
   * Please refer to [updated API](#/datasources/datasourceProxyPOSTByUIDcalls) instead
   */
  datasourceProxyPOSTcalls: {
    parameters: {
      path: {
        datasource_proxy_route: string;
        id: string;
      };
    };
    responses: {
      /** (empty) */
      201: unknown;
      /** (empty) */
      202: unknown;
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": unknown;
      };
    };
  };
  /**
   * Proxies all calls to the actual data source.
   *
   * Please refer to [updated API](#/datasources/datasourceProxyDELETEByUIDcalls) instead
   */
  datasourceProxyDELETEcalls: {
    parameters: {
      path: {
        id: string;
        datasource_proxy_route: string;
      };
    };
    responses: {
      /** (empty) */
      202: unknown;
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  getCorrelationsBySourceUID: {
    parameters: {
      path: {
        sourceUID: string;
      };
    };
    responses: {
      200: components["responses"]["getCorrelationsBySourceUIDResponse"];
      401: components["responses"]["unauthorisedError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  createCorrelation: {
    parameters: {
      path: {
        sourceUID: string;
      };
    };
    responses: {
      200: components["responses"]["createCorrelationResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateCorrelationCommand"];
      };
    };
  };
  getCorrelation: {
    parameters: {
      path: {
        sourceUID: string;
        correlationUID: string;
      };
    };
    responses: {
      200: components["responses"]["getCorrelationResponse"];
      401: components["responses"]["unauthorisedError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  updateCorrelation: {
    parameters: {
      path: {
        sourceUID: string;
        correlationUID: string;
      };
    };
    responses: {
      200: components["responses"]["updateCorrelationResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateCorrelationCommand"];
      };
    };
  };
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled
   * you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:uid:*` and `datasources:uid:kLtEtcRGk` (single data source).
   */
  getDataSourceByUID: {
    parameters: {
      path: {
        uid: string;
      };
    };
    responses: {
      200: components["responses"]["getDataSourceResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * Similar to creating a data source, `password` and `basicAuthPassword` should be defined under
   * secureJsonData in order to be stored securely as an encrypted blob in the database. Then, the
   * encrypted fields are listed under secureJsonFields section in the response.
   *
   * If you are running Grafana Enterprise and have Fine-grained access control enabled
   * you need to have a permission with action: `datasources:write` and scopes: `datasources:*`, `datasources:uid:*` and `datasources:uid:1` (single data source).
   */
  updateDataSourceByUID: {
    parameters: {
      path: {
        uid: string;
      };
    };
    responses: {
      200: components["responses"]["createOrUpdateDatasourceResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateDataSourceCommand"];
      };
    };
  };
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled
   * you need to have a permission with action: `datasources:delete` and scopes: `datasources:*`, `datasources:uid:*` and `datasources:uid:kLtEtcRGk` (single data source).
   */
  deleteDataSourceByUID: {
    parameters: {
      path: {
        uid: string;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  deleteCorrelation: {
    parameters: {
      path: {
        uid: string;
        correlationUID: string;
      };
    };
    responses: {
      200: components["responses"]["deleteCorrelationResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  checkDatasourceHealthWithUID: {
    parameters: {
      path: {
        uid: string;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  callDatasourceResourceWithUID: {
    parameters: {
      path: {
        datasource_proxy_route: string;
        uid: string;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled
   * you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:id:*` and `datasources:id:1` (single data source).
   *
   * Please refer to [updated API](#/datasources/getDataSourceByUID) instead
   */
  getDataSourceByID: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      200: components["responses"]["getDataSourceResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * Similar to creating a data source, `password` and `basicAuthPassword` should be defined under
   * secureJsonData in order to be stored securely as an encrypted blob in the database. Then, the
   * encrypted fields are listed under secureJsonFields section in the response.
   *
   * If you are running Grafana Enterprise and have Fine-grained access control enabled
   * you need to have a permission with action: `datasources:write` and scopes: `datasources:*`, `datasources:id:*` and `datasources:id:1` (single data source).
   *
   * Please refer to [updated API](#/datasources/updateDataSourceByUID) instead
   */
  updateDataSourceByID: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      200: components["responses"]["createOrUpdateDatasourceResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateDataSourceCommand"];
      };
    };
  };
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled
   * you need to have a permission with action: `datasources:delete` and scopes: `datasources:*`, `datasources:id:*` and `datasources:id:1` (single data source).
   *
   * Please refer to [updated API](#/datasources/deleteDataSourceByUID) instead
   */
  deleteDataSourceByID: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** Please refer to [updated API](#/datasources/checkDatasourceHealthWithUID) instead */
  checkDatasourceHealthByID: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** Please refer to [updated API](#/datasources/callDatasourceResourceWithUID) instead */
  callDatasourceResourceByID: {
    parameters: {
      path: {
        datasource_proxy_route: string;
        id: string;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled
   * you need to have a permission with action: `datasources:query`.
   */
  queryMetricsWithExpressions: {
    responses: {
      200: components["responses"]["queryMetricsWithExpressionsRespons"];
      207: components["responses"]["queryMetricsWithExpressionsRespons"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["MetricRequest"];
      };
    };
  };
  /**
   * Returns all folders that the authenticated user has permission to view.
   * If nested folders are enabled, it expects an additional query parameter with the parent folder UID
   * and returns the immediate subfolders that the authenticated user has permission to view.
   * If the parameter is not supplied then it returns immediate subfolders under the root
   * that the authenticated user has permission to view.
   */
  getFolders: {
    parameters: {
      query: {
        /** Limit the maximum number of folders to return */
        limit?: number;
        /** Page index for starting fetching folders */
        page?: number;
        /** The parent folder UID */
        parentUid?: string;
      };
    };
    responses: {
      200: components["responses"]["getFoldersResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** If nested folders are enabled then it additionally expects the parent folder UID. */
  createFolder: {
    responses: {
      200: components["responses"]["folderResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      409: components["responses"]["conflictError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateFolderCommand"];
      };
    };
  };
  /**
   * Returns the folder identified by id. This is deprecated.
   * Please refer to [updated API](#/folders/getFolderByUID) instead
   */
  getFolderByID: {
    parameters: {
      path: {
        folder_id: number;
      };
    };
    responses: {
      200: components["responses"]["folderResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  getFolderByUID: {
    parameters: {
      path: {
        folder_uid: string;
      };
    };
    responses: {
      200: components["responses"]["folderResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  updateFolder: {
    parameters: {
      path: {
        folder_uid: string;
      };
    };
    responses: {
      200: components["responses"]["folderResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      409: components["responses"]["conflictError"];
      500: components["responses"]["internalServerError"];
    };
    /**
     * To change the unique identifier (uid), provide another one.
     * To overwrite an existing folder with newer version, set `overwrite` to `true`.
     * Provide the current version to safelly update the folder: if the provided version differs from the stored one the request will fail, unless `overwrite` is `true`.
     */
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateFolderCommand"];
      };
    };
  };
  /**
   * Deletes an existing folder identified by UID along with all dashboards (and their alerts) stored in the folder. This operation cannot be reverted.
   * If nested folders are enabled then it also deletes all the subfolders.
   */
  deleteFolder: {
    parameters: {
      path: {
        folder_uid: string;
      };
      query: {
        /**
         * If `true` any Grafana 8 Alerts under this folder will be deleted.
         * Set to `false` so that the request will fail if the folder contains any Grafana 8 Alerts.
         */
        forceDeleteRules?: boolean;
      };
    };
    responses: {
      200: components["responses"]["deleteFolderResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  getFolderDescendantCounts: {
    parameters: {
      path: {
        folder_uid: string;
      };
    };
    responses: {
      200: components["responses"]["getFolderDescendantCountsResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  moveFolder: {
    parameters: {
      path: {
        folder_uid: string;
      };
    };
    responses: {
      200: components["responses"]["folderResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["MoveFolderCommand"];
      };
    };
  };
  getFolderPermissionList: {
    parameters: {
      path: {
        folder_uid: string;
      };
    };
    responses: {
      200: components["responses"]["getFolderPermissionListResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  updateFolderPermissions: {
    parameters: {
      path: {
        folder_uid: string;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateDashboardACLCommand"];
      };
    };
  };
  /**
   * Returns a list of all library elements the authenticated user has permission to view.
   * Use the `perPage` query parameter to control the maximum number of library elements returned; the default limit is `100`.
   * You can also use the `page` query parameter to fetch library elements from any page other than the first one.
   */
  getLibraryElements: {
    parameters: {
      query: {
        /** Part of the name or description searched for. */
        searchString?: string;
        /** Kind of element to search for. */
        kind?: 1 | 2;
        /** Sort order of elements. */
        sortDirection?: "alpha-asc" | "alpha-desc";
        /** A comma separated list of types to filter the elements by */
        typeFilter?: string;
        /** Element UID to exclude from search results. */
        excludeUid?: string;
        /** A comma separated list of folder ID(s) to filter the elements by. */
        folderFilter?: string;
        /** The number of results per page. */
        perPage?: number;
        /** The page for a set of records, given that only perPage records are returned at a time. Numbering starts at 1. */
        page?: number;
      };
    };
    responses: {
      200: components["responses"]["getLibraryElementsResponse"];
      401: components["responses"]["unauthorisedError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** Creates a new library element. */
  createLibraryElement: {
    responses: {
      200: components["responses"]["getLibraryElementResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateLibraryElementCommand"];
      };
    };
  };
  /** Returns a library element with the given name. */
  getLibraryElementByName: {
    parameters: {
      path: {
        library_element_name: string;
      };
    };
    responses: {
      200: components["responses"]["getLibraryElementArrayResponse"];
      401: components["responses"]["unauthorisedError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** Returns a library element with the given UID. */
  getLibraryElementByUID: {
    parameters: {
      path: {
        library_element_uid: string;
      };
    };
    responses: {
      200: components["responses"]["getLibraryElementResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * Deletes an existing library element as specified by the UID. This operation cannot be reverted.
   * You cannot delete a library element that is connected. This operation cannot be reverted.
   */
  deleteLibraryElementByUID: {
    parameters: {
      path: {
        library_element_uid: string;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** Updates an existing library element identified by uid. */
  updateLibraryElement: {
    parameters: {
      path: {
        library_element_uid: string;
      };
    };
    responses: {
      200: components["responses"]["getLibraryElementResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      412: components["responses"]["preconditionFailedError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PatchLibraryElementCommand"];
      };
    };
  };
  /** Returns a list of connections for a library element based on the UID specified. */
  getLibraryElementConnections: {
    parameters: {
      path: {
        library_element_uid: string;
      };
    };
    responses: {
      200: components["responses"]["getLibraryElementConnectionsResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  getStatus: {
    responses: {
      200: components["responses"]["getStatusResponse"];
    };
  };
  /** You need to have a permission with action `licensing.reports:read`. */
  getCustomPermissionsReport: {
    responses: {
      500: components["responses"]["internalServerError"];
    };
  };
  /** You need to have a permission with action `licensing.reports:read`. */
  getCustomPermissionsCSV: {
    responses: {
      500: components["responses"]["internalServerError"];
    };
  };
  /** You need to have a permission with action `licensing:read`. */
  refreshLicenseStats: {
    responses: {
      200: components["responses"]["refreshLicenseStatsResponse"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** You need to have a permission with action `licensing:read`. */
  getLicenseToken: {
    responses: {
      200: components["responses"]["getLicenseTokenResponse"];
    };
  };
  /** You need to have a permission with action `licensing:update`. */
  postLicenseToken: {
    responses: {
      200: components["responses"]["getLicenseTokenResponse"];
      400: components["responses"]["badRequestError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["DeleteTokenCommand"];
      };
    };
  };
  /**
   * Removes the license stored in the Grafana database. Available in Grafana Enterprise v7.4+.
   *
   * You need to have a permission with action `licensing:delete`.
   */
  deleteLicenseToken: {
    responses: {
      202: components["responses"]["acceptedResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      422: components["responses"]["unprocessableEntityError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["DeleteTokenCommand"];
      };
    };
  };
  /**
   * Manually ask license issuer for a new token. Available in Grafana Enterprise v7.4+.
   *
   * You need to have a permission with action `licensing:update`.
   */
  postRenewLicenseToken: {
    responses: {
      200: components["responses"]["postRenewLicenseTokenResponse"];
      401: components["responses"]["unauthorisedError"];
      404: components["responses"]["notFoundError"];
    };
    requestBody: {
      content: {
        "application/json": { [key: string]: unknown };
      };
    };
  };
  getSAMLLogout: {
    responses: {
      /** (empty) */
      302: never;
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  getCurrentOrg: {
    responses: {
      200: components["responses"]["getCurrentOrgResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  updateCurrentOrg: {
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateOrgForm"];
      };
    };
  };
  updateCurrentOrgAddress: {
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateOrgAddressForm"];
      };
    };
  };
  getPendingOrgInvites: {
    responses: {
      200: components["responses"]["getPendingOrgInvitesResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  addOrgInvite: {
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      412: components["responses"]["SMTPNotEnabledError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AddInviteForm"];
      };
    };
  };
  revokeInvite: {
    parameters: {
      path: {
        invitation_code: string;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  getOrgPreferences: {
    responses: {
      200: components["responses"]["getPreferencesResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  updateOrgPreferences: {
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdatePrefsCmd"];
      };
    };
  };
  patchOrgPreferences: {
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PatchPrefsCmd"];
      };
    };
  };
  /** If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `orgs.quotas:read` and scope `org:id:1` (orgIDScope). */
  getCurrentOrgQuota: {
    responses: {
      200: components["responses"]["getQuotaResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * Returns all org users within the current organization. Accessible to users with org admin role.
   * If you are running Grafana Enterprise and have Fine-grained access control enabled
   * you need to have a permission with action: `org.users:read` with scope `users:*`.
   */
  getOrgUsersForCurrentOrg: {
    responses: {
      200: components["responses"]["getOrgUsersForCurrentOrgResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * Adds a global user to the current organization.
   *
   * If you are running Grafana Enterprise and have Fine-grained access control enabled
   * you need to have a permission with action: `org.users:add` with scope `users:*`.
   */
  addOrgUserToCurrentOrg: {
    responses: {
      200: components["responses"]["okResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AddOrgUserCommand"];
      };
    };
  };
  /**
   * Returns all org users within the current organization, but with less detailed information.
   * Accessible to users with org admin role, admin in any folder or admin of any team.
   * Mainly used by Grafana UI for providing list of users when adding team members and when editing folder/dashboard permissions.
   */
  getOrgUsersForCurrentOrgLookup: {
    parameters: {
      query: {
        query?: string;
        limit?: number;
      };
    };
    responses: {
      200: components["responses"]["getOrgUsersForCurrentOrgLookupResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled
   * you need to have a permission with action: `org.users:remove` with scope `users:*`.
   */
  removeOrgUserForCurrentOrg: {
    parameters: {
      path: {
        user_id: number;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled
   * you need to have a permission with action: `org.users.role:update` with scope `users:*`.
   */
  updateOrgUserForCurrentOrg: {
    parameters: {
      path: {
        user_id: number;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateOrgUserCommand"];
      };
    };
  };
  searchOrgs: {
    parameters: {
      query: {
        page?: number;
        /**
         * Number of items per page
         * The totalCount field in the response can be used for pagination list E.g. if totalCount is equal to 100 teams and the perpage parameter is set to 10 then there are 10 pages of teams.
         */
        perpage?: number;
        name?: string;
        /** If set it will return results where the query value is contained in the name field. Query values with spaces need to be URL encoded. */
        query?: string;
      };
    };
    responses: {
      200: components["responses"]["searchOrgsResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      409: components["responses"]["conflictError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** Only works if [users.allow_org_create](https://grafana.com/docs/grafana/latest/administration/configuration/#allow_org_create) is set. */
  createOrg: {
    responses: {
      200: components["responses"]["createOrgResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      409: components["responses"]["conflictError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateOrgCommand"];
      };
    };
  };
  getOrgByName: {
    parameters: {
      path: {
        org_name: string;
      };
    };
    responses: {
      200: components["responses"]["getOrgByNameResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  getOrgByID: {
    parameters: {
      path: {
        org_id: number;
      };
    };
    responses: {
      200: components["responses"]["getOrgByIDResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  updateOrg: {
    parameters: {
      path: {
        org_id: number;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateOrgForm"];
      };
    };
  };
  deleteOrgByID: {
    parameters: {
      path: {
        org_id: number;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  updateOrgAddress: {
    parameters: {
      path: {
        org_id: number;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateOrgAddressForm"];
      };
    };
  };
  /** If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `orgs.quotas:read` and scope `org:id:1` (orgIDScope). */
  getOrgQuota: {
    parameters: {
      path: {
        org_id: number;
      };
    };
    responses: {
      200: components["responses"]["getQuotaResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `orgs.quotas:write` and scope `org:id:1` (orgIDScope). */
  updateOrgQuota: {
    parameters: {
      path: {
        quota_target: string;
        org_id: number;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateQuotaCmd"];
      };
    };
  };
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled
   * you need to have a permission with action: `org.users:read` with scope `users:*`.
   */
  getOrgUsers: {
    parameters: {
      path: {
        org_id: number;
      };
    };
    responses: {
      200: components["responses"]["getOrgUsersResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * Adds a global user to the current organization.
   *
   * If you are running Grafana Enterprise and have Fine-grained access control enabled
   * you need to have a permission with action: `org.users:add` with scope `users:*`.
   */
  addOrgUser: {
    parameters: {
      path: {
        org_id: number;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AddOrgUserCommand"];
      };
    };
  };
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled
   * you need to have a permission with action: `org.users:read` with scope `users:*`.
   */
  searchOrgUsers: {
    parameters: {
      path: {
        org_id: number;
      };
    };
    responses: {
      200: components["responses"]["searchOrgUsersResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled
   * you need to have a permission with action: `org.users:remove` with scope `users:*`.
   */
  removeOrgUser: {
    parameters: {
      path: {
        org_id: number;
        user_id: number;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled
   * you need to have a permission with action: `org.users.role:update` with scope `users:*`.
   */
  updateOrgUser: {
    parameters: {
      path: {
        org_id: number;
        user_id: number;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateOrgUserCommand"];
      };
    };
  };
  searchPlaylists: {
    parameters: {
      query: {
        query?: string;
        /** in:limit */
        limit?: number;
      };
    };
    responses: {
      200: components["responses"]["searchPlaylistsResponse"];
      500: components["responses"]["internalServerError"];
    };
  };
  createPlaylist: {
    responses: {
      200: components["responses"]["createPlaylistResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreatePlaylistCommand"];
      };
    };
  };
  getPlaylist: {
    parameters: {
      path: {
        uid: string;
      };
    };
    responses: {
      200: components["responses"]["getPlaylistResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  updatePlaylist: {
    parameters: {
      path: {
        uid: string;
      };
    };
    responses: {
      200: components["responses"]["updatePlaylistResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdatePlaylistCommand"];
      };
    };
  };
  deletePlaylist: {
    parameters: {
      path: {
        uid: string;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  getPlaylistItems: {
    parameters: {
      path: {
        uid: string;
      };
    };
    responses: {
      200: components["responses"]["getPlaylistItemsResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** Get public dashboard for view */
  viewPublicDashboard: {
    parameters: {
      path: {
        accessToken: string;
      };
    };
    responses: {
      200: components["responses"]["viewPublicDashboardResponse"];
      400: components["responses"]["badRequestPublicError"];
      401: components["responses"]["unauthorisedPublicError"];
      403: components["responses"]["forbiddenPublicError"];
      404: components["responses"]["notFoundPublicError"];
      500: components["responses"]["internalServerPublicError"];
    };
  };
  /** Get annotations for a public dashboard */
  getPublicAnnotations: {
    parameters: {
      path: {
        accessToken: string;
      };
    };
    responses: {
      200: components["responses"]["getPublicAnnotationsResponse"];
      400: components["responses"]["badRequestPublicError"];
      401: components["responses"]["unauthorisedPublicError"];
      403: components["responses"]["forbiddenPublicError"];
      404: components["responses"]["notFoundPublicError"];
      500: components["responses"]["internalServerPublicError"];
    };
  };
  /** Get results for a given panel on a public dashboard */
  queryPublicDashboard: {
    parameters: {
      path: {
        accessToken: string;
        panelId: number;
      };
    };
    responses: {
      200: components["responses"]["queryPublicDashboardResponse"];
      400: components["responses"]["badRequestPublicError"];
      401: components["responses"]["unauthorisedPublicError"];
      403: components["responses"]["forbiddenPublicError"];
      404: components["responses"]["notFoundPublicError"];
      500: components["responses"]["internalServerPublicError"];
    };
  };
  /**
   * Returns a list of queries in the query history that matches the search criteria.
   * Query history search supports pagination. Use the `limit` parameter to control the maximum number of queries returned; the default limit is 100.
   * You can also use the `page` query parameter to fetch queries from any page other than the first one.
   */
  searchQueries: {
    parameters: {
      query: {
        /** List of data source UIDs to search for */
        datasourceUid?: string[];
        /** Text inside query or comments that is searched for */
        searchString?: string;
        /** Flag indicating if only starred queries should be returned */
        onlyStarred?: boolean;
        /** Sort method */
        sort?: "time-desc" | "time-asc";
        /** Use this parameter to access hits beyond limit. Numbering starts at 1. limit param acts as page size. */
        page?: number;
        /** Limit the number of returned results */
        limit?: number;
        /** From range for the query history search */
        from?: number;
        /** To range for the query history search */
        to?: number;
      };
    };
    responses: {
      200: components["responses"]["getQueryHistorySearchResponse"];
      401: components["responses"]["unauthorisedError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** Adds new query to query history. */
  createQuery: {
    responses: {
      200: components["responses"]["getQueryHistoryResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateQueryInQueryHistoryCommand"];
      };
    };
  };
  /** Adds star to query in query history as specified by the UID. */
  starQuery: {
    parameters: {
      path: {
        query_history_uid: string;
      };
    };
    responses: {
      200: components["responses"]["getQueryHistoryResponse"];
      401: components["responses"]["unauthorisedError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** Removes star from query in query history as specified by the UID. */
  unstarQuery: {
    parameters: {
      path: {
        query_history_uid: string;
      };
    };
    responses: {
      200: components["responses"]["getQueryHistoryResponse"];
      401: components["responses"]["unauthorisedError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** Deletes an existing query in query history as specified by the UID. This operation cannot be reverted. */
  deleteQuery: {
    parameters: {
      path: {
        query_history_uid: string;
      };
    };
    responses: {
      200: components["responses"]["getQueryHistoryDeleteQueryResponse"];
      401: components["responses"]["unauthorisedError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** Updates comment for query in query history as specified by the UID. */
  patchQueryComment: {
    parameters: {
      path: {
        query_history_uid: string;
      };
    };
    responses: {
      200: components["responses"]["getQueryHistoryResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PatchQueryCommentInQueryHistoryCommand"];
      };
    };
  };
  listRecordingRules: {
    responses: {
      200: components["responses"]["listRecordingRulesResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  updateRecordingRule: {
    responses: {
      200: components["responses"]["recordingRuleResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["RecordingRuleJSON"];
      };
    };
  };
  createRecordingRule: {
    responses: {
      200: components["responses"]["recordingRuleResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["RecordingRuleJSON"];
      };
    };
  };
  testCreateRecordingRule: {
    responses: {
      200: components["responses"]["okResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      422: components["responses"]["unprocessableEntityError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["RecordingRuleJSON"];
      };
    };
  };
  getRecordingRuleWriteTarget: {
    responses: {
      200: components["responses"]["recordingRuleWriteTargetResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** It returns a 422 if there is not an existing prometheus data source configured. */
  createRecordingRuleWriteTarget: {
    responses: {
      200: components["responses"]["recordingRuleWriteTargetResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      422: components["responses"]["unprocessableEntityError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PrometheusRemoteWriteTargetJSON"];
      };
    };
  };
  deleteRecordingRuleWriteTarget: {
    responses: {
      200: components["responses"]["okResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  deleteRecordingRule: {
    parameters: {
      path: {
        recordingRuleID: number;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * Available to org admins only and with a valid or expired license.
   *
   * You need to have a permission with action `reports:read` with scope `reports:*`.
   */
  getReports: {
    responses: {
      200: components["responses"]["getReportsResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * Available to org admins only and with a valid license.
   *
   * You need to have a permission with action `reports.admin:create`.
   */
  createReport: {
    responses: {
      200: components["responses"]["createReportResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateOrUpdateReportConfig"];
      };
    };
  };
  /**
   * Generate and send a report. This API waits for the report to be generated before returning. We recommend that you set the client’s timeout to at least 60 seconds. Available to org admins only and with a valid license.
   *
   * Only available in Grafana Enterprise v7.0+.
   * This API endpoint is experimental and may be deprecated in a future release. On deprecation, a migration strategy will be provided and the endpoint will remain functional until the next major release of Grafana.
   *
   * You need to have a permission with action `reports:send`.
   */
  sendReport: {
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ReportEmail"];
      };
    };
  };
  /** Please refer to [reports enterprise](#/reports/renderReportPDFs) instead. This will be removed in Grafana 10. */
  renderReportPDF: {
    parameters: {
      path: {
        dashboardID: number;
      };
      query: {
        title?: string;
        variables?: string;
        from?: string;
        to?: string;
        orientation?: string;
        layout?: string;
      };
    };
    responses: {
      200: components["responses"]["contentResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** Available to all users and with a valid license. */
  renderReportPDFs: {
    parameters: {
      query: {
        dashboardID?: string;
        orientation?: string;
        layout?: string;
        title?: string;
        scaleFactor?: string;
        includeTables?: string;
      };
    };
    responses: {
      200: components["responses"]["contentResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * Available to org admins only and with a valid or expired license.
   *
   * You need to have a permission with action `reports.settings:read`x.
   */
  getReportSettings: {
    responses: {
      200: components["responses"]["getReportSettingsResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * Available to org admins only and with a valid or expired license.
   *
   * You need to have a permission with action `reports.settings:write`xx.
   */
  saveReportSettings: {
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ReportSettings"];
      };
    };
  };
  /**
   * Available to org admins only and with a valid license.
   *
   * You need to have a permission with action `reports:send`.
   */
  sendTestEmail: {
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateOrUpdateReportConfig"];
      };
    };
  };
  /**
   * Available to org admins only and with a valid or expired license.
   *
   * You need to have a permission with action `reports:read` with scope `reports:id:<report ID>`.
   */
  getReport: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      200: components["responses"]["getReportResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * Available to org admins only and with a valid or expired license.
   *
   * You need to have a permission with action `reports.admin:write` with scope `reports:id:<report ID>`.
   */
  updateReport: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateOrUpdateReportConfig"];
      };
    };
  };
  /**
   * Available to org admins only and with a valid or expired license.
   *
   * You need to have a permission with action `reports.delete` with scope `reports:id:<report ID>`.
   */
  deleteReport: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  postACS: {
    parameters: {
      query: {
        RelayState?: string;
      };
    };
    responses: {
      /** (empty) */
      302: never;
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  getMetadata: {
    responses: {
      200: components["responses"]["contentResponse"];
    };
  };
  /**
   * There might be two possible requests:
   * 1. Logout response (callback) when Grafana initiates single logout and IdP returns response to logout request.
   * 2. Logout request when another SP initiates single logout and IdP sends logout request to the Grafana,
   * or in case of IdP-initiated logout.
   */
  getSLO: {
    responses: {
      /** (empty) */
      302: never;
      400: components["responses"]["badRequestError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * There might be two possible requests:
   * 1. Logout response (callback) when Grafana initiates single logout and IdP returns response to logout request.
   * 2. Logout request when another SP initiates single logout and IdP sends logout request to the Grafana,
   * or in case of IdP-initiated logout.
   */
  postSLO: {
    parameters: {
      query: {
        SAMLRequest?: string;
        SAMLResponse?: string;
      };
    };
    responses: {
      /** (empty) */
      302: never;
      400: components["responses"]["badRequestError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  search: {
    parameters: {
      query: {
        /** Search Query */
        query?: string;
        /** List of tags to search for */
        tag?: string[];
        /** Type to search for, dash-folder or dash-db */
        type?: "dash-folder" | "dash-db";
        /**
         * List of dashboard id’s to search for
         * This is deprecated: users should use the `dashboardUIDs` query parameter instead
         */
        dashboardIds?: number[];
        /** List of dashboard uid’s to search for */
        dashboardUIDs?: string[];
        /**
         * List of folder id’s to search in for dashboards
         * If it's `0` then it will query for the top level folders
         * This is deprecated: users should use the `folderUIDs` query parameter instead
         */
        folderIds?: number[];
        /**
         * List of folder UID’s to search in for dashboards
         * If it's an empty string then it will query for the top level folders
         */
        folderUIDs?: string[];
        /** Flag indicating if only starred Dashboards should be returned */
        starred?: boolean;
        /** Limit the number of returned results (max 5000) */
        limit?: number;
        /** Use this parameter to access hits beyond limit. Numbering starts at 1. limit param acts as page size. Only available in Grafana v6.2+. */
        page?: number;
        /** Set to `Edit` to return dashboards/folders that the user can edit */
        permission?: "Edit" | "View";
        /** Sort method; for listing all the possible sort methods use the search sorting endpoint. */
        sort?: "alpha-asc" | "alpha-desc";
      };
    };
    responses: {
      200: components["responses"]["searchResponse"];
      401: components["responses"]["unauthorisedError"];
      422: components["responses"]["unprocessableEntityError"];
      500: components["responses"]["internalServerError"];
    };
  };
  SearchDevices: {
    responses: {
      200: components["responses"]["devicesSearchResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  listSortOptions: {
    responses: {
      200: components["responses"]["listSortOptionsResponse"];
      401: components["responses"]["unauthorisedError"];
    };
  };
  /**
   * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation):
   * action: `serviceaccounts:write` scope: `serviceaccounts:*`
   *
   * Requires basic authentication and that the authenticated user is a Grafana Admin.
   */
  createServiceAccount: {
    responses: {
      201: components["responses"]["createServiceAccountResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateServiceAccountForm"];
      };
    };
  };
  /**
   * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation):
   * action: `serviceaccounts:read` scope: `serviceaccounts:*`
   */
  searchOrgServiceAccountsWithPaging: {
    parameters: {
      query: {
        Disabled?: boolean;
        expiredTokens?: boolean;
        /**
         * It will return results where the query value is contained in one of the name.
         * Query values with spaces need to be URL encoded.
         */
        query?: string;
        /** The default value is 1000. */
        perpage?: number;
        /** The default value is 1. */
        page?: number;
      };
    };
    responses: {
      200: components["responses"]["searchOrgServiceAccountsWithPagingResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation):
   * action: `serviceaccounts:read` scope: `serviceaccounts:id:1` (single service account)
   */
  retrieveServiceAccount: {
    parameters: {
      path: {
        serviceAccountId: number;
      };
    };
    responses: {
      200: components["responses"]["retrieveServiceAccountResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation):
   * action: `serviceaccounts:delete` scope: `serviceaccounts:id:1` (single service account)
   */
  deleteServiceAccount: {
    parameters: {
      path: {
        serviceAccountId: number;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation):
   * action: `serviceaccounts:write` scope: `serviceaccounts:id:1` (single service account)
   */
  updateServiceAccount: {
    parameters: {
      path: {
        serviceAccountId: number;
      };
    };
    responses: {
      200: components["responses"]["updateServiceAccountResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateServiceAccountForm"];
      };
    };
  };
  /**
   * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation):
   * action: `serviceaccounts:read` scope: `global:serviceaccounts:id:1` (single service account)
   *
   * Requires basic authentication and that the authenticated user is a Grafana Admin.
   */
  listTokens: {
    parameters: {
      path: {
        serviceAccountId: number;
      };
    };
    responses: {
      200: components["responses"]["listTokensResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation):
   * action: `serviceaccounts:write` scope: `serviceaccounts:id:1` (single service account)
   */
  createToken: {
    parameters: {
      path: {
        serviceAccountId: number;
      };
    };
    responses: {
      200: components["responses"]["createTokenResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      409: components["responses"]["conflictError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AddServiceAccountTokenCommand"];
      };
    };
  };
  /**
   * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation):
   * action: `serviceaccounts:write` scope: `serviceaccounts:id:1` (single service account)
   *
   * Requires basic authentication and that the authenticated user is a Grafana Admin.
   */
  deleteToken: {
    parameters: {
      path: {
        tokenId: number;
        serviceAccountId: number;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /**
   * Required permissions
   * None
   */
  retrieveJWKS: {
    responses: {
      200: components["responses"]["jwksResponse"];
      500: components["responses"]["internalServerError"];
    };
  };
  getSharingOptions: {
    responses: {
      200: components["responses"]["getSharingOptionsResponse"];
      401: components["responses"]["unauthorisedError"];
    };
  };
  /** Snapshot public mode should be enabled or authentication is required. */
  createDashboardSnapshot: {
    responses: {
      200: components["responses"]["createDashboardSnapshotResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateDashboardSnapshotCommand"];
      };
    };
  };
  /** Snapshot public mode should be enabled or authentication is required. */
  deleteDashboardSnapshotByDeleteKey: {
    parameters: {
      path: {
        deleteKey: string;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  getDashboardSnapshot: {
    parameters: {
      path: {
        key: string;
      };
    };
    responses: {
      200: components["responses"]["getDashboardSnapshotResponse"];
      400: components["responses"]["badRequestError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  deleteDashboardSnapshot: {
    parameters: {
      path: {
        key: string;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  listDevices: {
    responses: {
      200: components["responses"]["devicesResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  createTeam: {
    responses: {
      200: components["responses"]["createTeamResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      409: components["responses"]["conflictError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateTeamCommand"];
      };
    };
  };
  searchTeams: {
    parameters: {
      query: {
        page?: number;
        /**
         * Number of items per page
         * The totalCount field in the response can be used for pagination list E.g. if totalCount is equal to 100 teams and the perpage parameter is set to 10 then there are 10 pages of teams.
         */
        perpage?: number;
        name?: string;
        /** If set it will return results where the query value is contained in the name field. Query values with spaces need to be URL encoded. */
        query?: string;
      };
    };
    responses: {
      200: components["responses"]["searchTeamsResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  getTeamGroupsApi: {
    parameters: {
      path: {
        teamId: number;
      };
    };
    responses: {
      200: components["responses"]["getTeamGroupsApiResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  addTeamGroupApi: {
    parameters: {
      path: {
        teamId: number;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["TeamGroupMapping"];
      };
    };
  };
  removeTeamGroupApiQuery: {
    parameters: {
      query: {
        groupId?: string;
      };
      path: {
        teamId: number;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  getTeamByID: {
    parameters: {
      path: {
        team_id: string;
      };
    };
    responses: {
      200: components["responses"]["getTeamByIDResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  updateTeam: {
    parameters: {
      path: {
        team_id: string;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      409: components["responses"]["conflictError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateTeamCommand"];
      };
    };
  };
  deleteTeamByID: {
    parameters: {
      path: {
        team_id: string;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  getTeamMembers: {
    parameters: {
      path: {
        team_id: string;
      };
    };
    responses: {
      200: components["responses"]["getTeamMembersResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  addTeamMember: {
    parameters: {
      path: {
        team_id: string;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AddTeamMemberCommand"];
      };
    };
  };
  updateTeamMember: {
    parameters: {
      path: {
        team_id: string;
        user_id: number;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateTeamMemberCommand"];
      };
    };
  };
  removeTeamMember: {
    parameters: {
      path: {
        team_id: string;
        user_id: number;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  getTeamPreferences: {
    parameters: {
      path: {
        team_id: string;
      };
    };
    responses: {
      200: components["responses"]["getPreferencesResponse"];
      401: components["responses"]["unauthorisedError"];
      500: components["responses"]["internalServerError"];
    };
  };
  updateTeamPreferences: {
    parameters: {
      path: {
        team_id: string;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdatePrefsCmd"];
      };
    };
  };
  /** Get (current authenticated user) */
  getSignedInUser: {
    responses: {
      200: components["responses"]["userResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  updateSignedInUser: {
    responses: {
      200: components["responses"]["okResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      409: components["responses"]["conflictError"];
      500: components["responses"]["internalServerError"];
    };
    /** To change the email, name, login, theme, provide another one. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateUserCommand"];
      };
    };
  };
  /** Return a list of all auth tokens (devices) that the actual user currently have logged in from. */
  getUserAuthTokens: {
    responses: {
      200: components["responses"]["getUserAuthTokensResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** Update the email of user given a verification code. */
  updateUserEmail: {
    responses: {
      302: components["responses"]["okResponse"];
    };
  };
  clearHelpFlags: {
    responses: {
      200: components["responses"]["helpFlagResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  setHelpFlag: {
    parameters: {
      path: {
        flag_id: string;
      };
    };
    responses: {
      200: components["responses"]["helpFlagResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** Return a list of all organizations of the current user. */
  getSignedInUserOrgList: {
    responses: {
      200: components["responses"]["getSignedInUserOrgListResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** Changes the password for the user. */
  changeUserPassword: {
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
    /** To change the email, name, login, theme, provide another one. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["ChangeUserPasswordCommand"];
      };
    };
  };
  getUserPreferences: {
    responses: {
      200: components["responses"]["getPreferencesResponse"];
      401: components["responses"]["unauthorisedError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** Omitting a key (`theme`, `homeDashboardId`, `timezone`) will cause the current value to be replaced with the system default value. */
  updateUserPreferences: {
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdatePrefsCmd"];
      };
    };
  };
  patchUserPreferences: {
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PatchPrefsCmd"];
      };
    };
  };
  getUserQuotas: {
    responses: {
      200: components["responses"]["getQuotaResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** Revokes the given auth token (device) for the actual user. User of issued auth token (device) will no longer be logged in and will be required to authenticate again upon next activity. */
  revokeUserAuthToken: {
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["RevokeAuthTokenCmd"];
      };
    };
  };
  /** Stars the given Dashboard for the actual user. */
  starDashboardByUID: {
    parameters: {
      path: {
        dashboard_uid: string;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** Deletes the starring of the given Dashboard for the actual user. */
  unstarDashboardByUID: {
    parameters: {
      path: {
        dashboard_uid: string;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** Stars the given Dashboard for the actual user. */
  starDashboard: {
    parameters: {
      path: {
        dashboard_id: string;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** Deletes the starring of the given Dashboard for the actual user. */
  unstarDashboard: {
    parameters: {
      path: {
        dashboard_id: string;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** Return a list of all teams that the current user is member of. */
  getSignedInUserTeamList: {
    responses: {
      200: components["responses"]["getSignedInUserTeamListResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** Switch user context to the given organization. */
  userSetUsingOrg: {
    parameters: {
      path: {
        org_id: number;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** Returns all users that the authenticated user has permission to view, admin permission required. */
  searchUsers: {
    parameters: {
      query: {
        /** Limit the maximum number of users to return per page */
        perpage?: number;
        /** Page index for starting fetching users */
        page?: number;
      };
    };
    responses: {
      200: components["responses"]["searchUsersResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
  };
  getUserByLoginOrEmail: {
    parameters: {
      query: {
        /** loginOrEmail of the user */
        loginOrEmail: string;
      };
    };
    responses: {
      200: components["responses"]["userResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  searchUsersWithPaging: {
    responses: {
      200: components["responses"]["searchUsersWithPagingResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  getUserByID: {
    parameters: {
      path: {
        user_id: number;
      };
    };
    responses: {
      200: components["responses"]["userResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** Update the user identified by id. */
  updateUser: {
    parameters: {
      path: {
        user_id: number;
      };
    };
    responses: {
      200: components["responses"]["okResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      409: components["responses"]["conflictError"];
      500: components["responses"]["internalServerError"];
    };
    /** To change the email, name, login, theme, provide another one. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateUserCommand"];
      };
    };
  };
  /** Get organizations for user identified by id. */
  getUserOrgList: {
    parameters: {
      path: {
        user_id: number;
      };
    };
    responses: {
      200: components["responses"]["getUserOrgListResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  /** Get teams for user identified by id. */
  getUserTeams: {
    parameters: {
      path: {
        user_id: number;
      };
    };
    responses: {
      200: components["responses"]["getUserTeamsResponse"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
  RouteGetAlertRules: {
    responses: {
      /** ProvisionedAlertRules */
      200: {
        content: {
          "application/json": components["schemas"]["ProvisionedAlertRules"];
        };
      };
    };
  };
  RoutePostAlertRule: {
    parameters: {
      header: {
        "X-Disable-Provenance"?: string;
      };
    };
    responses: {
      /** ProvisionedAlertRule */
      201: {
        content: {
          "application/json": components["schemas"]["ProvisionedAlertRule"];
        };
      };
      /** ValidationError */
      400: {
        content: {
          "application/json": components["schemas"]["ValidationError"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ProvisionedAlertRule"];
      };
    };
  };
  RouteGetAlertRulesExport: {
    parameters: {
      query: {
        /** Whether to initiate a download of the file or not. */
        download?: boolean;
        /** Format of the downloaded file, either yaml or json. Accept header can also be used, but the query parameter will take precedence. */
        format?: string;
        /** UIDs of folders from which to export rules */
        folderUid?: string[];
        /** Name of group of rules to export. Must be specified only together with a single folder UID */
        group?: string;
        /** UID of alert rule to export. If specified, parameters folderUid and group must be empty. */
        ruleUid?: string;
      };
    };
    responses: {
      /** AlertingFileExport */
      200: {
        content: {
          "application/json": components["schemas"]["AlertingFileExport"];
        };
      };
      /** Not found. */
      404: unknown;
    };
  };
  RouteGetAlertRule: {
    parameters: {
      path: {
        /** Alert rule UID */
        UID: string;
      };
    };
    responses: {
      /** ProvisionedAlertRule */
      200: {
        content: {
          "application/json": components["schemas"]["ProvisionedAlertRule"];
        };
      };
      /** Not found. */
      404: unknown;
    };
  };
  RoutePutAlertRule: {
    parameters: {
      path: {
        /** Alert rule UID */
        UID: string;
      };
      header: {
        "X-Disable-Provenance"?: string;
      };
    };
    responses: {
      /** ProvisionedAlertRule */
      200: {
        content: {
          "application/json": components["schemas"]["ProvisionedAlertRule"];
        };
      };
      /** ValidationError */
      400: {
        content: {
          "application/json": components["schemas"]["ValidationError"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ProvisionedAlertRule"];
      };
    };
  };
  RouteDeleteAlertRule: {
    parameters: {
      path: {
        /** Alert rule UID */
        UID: string;
      };
      header: {
        "X-Disable-Provenance"?: string;
      };
    };
    responses: {
      /** The alert rule was deleted successfully. */
      204: never;
    };
  };
  RouteGetAlertRuleExport: {
    parameters: {
      query: {
        /** Whether to initiate a download of the file or not. */
        download?: boolean;
        /** Format of the downloaded file, either yaml or json. Accept header can also be used, but the query parameter will take precedence. */
        format?: string;
      };
      path: {
        /** Alert rule UID */
        UID: string;
      };
    };
    responses: {
      /** AlertingFileExport */
      200: {
        content: {
          "application/json": components["schemas"]["AlertingFileExport"];
          "application/yaml": components["schemas"]["AlertingFileExport"];
          "text/yaml": components["schemas"]["AlertingFileExport"];
        };
      };
      /** Not found. */
      404: unknown;
    };
  };
  RouteGetContactpoints: {
    parameters: {
      query: {
        /** Filter by name */
        name?: string;
      };
    };
    responses: {
      /** ContactPoints */
      200: {
        content: {
          "application/json": components["schemas"]["ContactPoints"];
        };
      };
    };
  };
  RoutePostContactpoints: {
    parameters: {
      header: {
        "X-Disable-Provenance"?: string;
      };
    };
    responses: {
      /** EmbeddedContactPoint */
      202: {
        content: {
          "application/json": components["schemas"]["EmbeddedContactPoint"];
        };
      };
      /** ValidationError */
      400: {
        content: {
          "application/json": components["schemas"]["ValidationError"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["EmbeddedContactPoint"];
      };
    };
  };
  RouteGetContactpointsExport: {
    parameters: {
      query: {
        /** Whether to initiate a download of the file or not. */
        download?: boolean;
        /** Format of the downloaded file, either yaml or json. Accept header can also be used, but the query parameter will take precedence. */
        format?: string;
        /** Whether any contained secure settings should be decrypted or left redacted. Redacted settings will contain RedactedValue instead. Currently, only org admin can view decrypted secure settings. */
        decrypt?: boolean;
        /** Filter by name */
        name?: string;
      };
    };
    responses: {
      /** AlertingFileExport */
      200: {
        content: {
          "application/json": components["schemas"]["AlertingFileExport"];
        };
      };
      /** PermissionDenied */
      403: {
        content: {
          "application/json": components["schemas"]["PermissionDenied"];
        };
      };
    };
  };
  RoutePutContactpoint: {
    parameters: {
      path: {
        /** UID is the contact point unique identifier */
        UID: string;
      };
      header: {
        "X-Disable-Provenance"?: string;
      };
    };
    responses: {
      /** Ack */
      202: {
        content: {
          "application/json": components["schemas"]["Ack"];
        };
      };
      /** ValidationError */
      400: {
        content: {
          "application/json": components["schemas"]["ValidationError"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["EmbeddedContactPoint"];
      };
    };
  };
  RouteDeleteContactpoints: {
    parameters: {
      path: {
        /** UID is the contact point unique identifier */
        UID: string;
      };
    };
    responses: {
      /** The contact point was deleted successfully. */
      202: unknown;
    };
  };
  RouteGetAlertRuleGroup: {
    parameters: {
      path: {
        FolderUID: string;
        Group: string;
      };
    };
    responses: {
      /** AlertRuleGroup */
      200: {
        content: {
          "application/json": components["schemas"]["AlertRuleGroup"];
        };
      };
      /** Not found. */
      404: unknown;
    };
  };
  RoutePutAlertRuleGroup: {
    parameters: {
      header: {
        "X-Disable-Provenance"?: string;
      };
      path: {
        FolderUID: string;
        Group: string;
      };
    };
    responses: {
      /** AlertRuleGroup */
      200: {
        content: {
          "application/json": components["schemas"]["AlertRuleGroup"];
        };
      };
      /** ValidationError */
      400: {
        content: {
          "application/json": components["schemas"]["ValidationError"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AlertRuleGroup"];
      };
    };
  };
  RouteGetAlertRuleGroupExport: {
    parameters: {
      query: {
        /** Whether to initiate a download of the file or not. */
        download?: boolean;
        /** Format of the downloaded file, either yaml or json. Accept header can also be used, but the query parameter will take precedence. */
        format?: string;
      };
      path: {
        FolderUID: string;
        Group: string;
      };
    };
    responses: {
      /** AlertingFileExport */
      200: {
        content: {
          "application/json": components["schemas"]["AlertingFileExport"];
          "application/yaml": components["schemas"]["AlertingFileExport"];
          "text/yaml": components["schemas"]["AlertingFileExport"];
        };
      };
      /** Not found. */
      404: unknown;
    };
  };
  RouteGetMuteTimings: {
    responses: {
      /** MuteTimings */
      200: {
        content: {
          "application/json": components["schemas"]["MuteTimings"];
        };
      };
    };
  };
  RoutePostMuteTiming: {
    parameters: {
      header: {
        "X-Disable-Provenance"?: string;
      };
    };
    responses: {
      /** MuteTimeInterval */
      201: {
        content: {
          "application/json": components["schemas"]["MuteTimeInterval"];
        };
      };
      /** ValidationError */
      400: {
        content: {
          "application/json": components["schemas"]["ValidationError"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["MuteTimeInterval"];
      };
    };
  };
  RouteExportMuteTimings: {
    parameters: {
      query: {
        /** Whether to initiate a download of the file or not. */
        download?: boolean;
        /** Format of the downloaded file, either yaml or json. Accept header can also be used, but the query parameter will take precedence. */
        format?: string;
      };
    };
    responses: {
      /** AlertingFileExport */
      200: {
        content: {
          "application/json": components["schemas"]["AlertingFileExport"];
        };
      };
      /** PermissionDenied */
      403: {
        content: {
          "application/json": components["schemas"]["PermissionDenied"];
        };
      };
    };
  };
  RouteGetMuteTiming: {
    parameters: {
      path: {
        /** Mute timing name */
        name: string;
      };
    };
    responses: {
      /** MuteTimeInterval */
      200: {
        content: {
          "application/json": components["schemas"]["MuteTimeInterval"];
        };
      };
      /** Not found. */
      404: unknown;
    };
  };
  RoutePutMuteTiming: {
    parameters: {
      path: {
        /** Mute timing name */
        name: string;
      };
      header: {
        "X-Disable-Provenance"?: string;
      };
    };
    responses: {
      /** MuteTimeInterval */
      202: {
        content: {
          "application/json": components["schemas"]["MuteTimeInterval"];
        };
      };
      /** ValidationError */
      400: {
        content: {
          "application/json": components["schemas"]["ValidationError"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["MuteTimeInterval"];
      };
    };
  };
  RouteDeleteMuteTiming: {
    parameters: {
      path: {
        /** Mute timing name */
        name: string;
      };
    };
    responses: {
      /** The mute timing was deleted successfully. */
      204: never;
      /** GenericPublicError */
      409: {
        content: {
          "application/json": components["schemas"]["GenericPublicError"];
        };
      };
    };
  };
  RouteExportMuteTiming: {
    parameters: {
      query: {
        /** Whether to initiate a download of the file or not. */
        download?: boolean;
        /** Format of the downloaded file, either yaml or json. Accept header can also be used, but the query parameter will take precedence. */
        format?: string;
      };
      path: {
        /** Mute timing name */
        name: string;
      };
    };
    responses: {
      /** AlertingFileExport */
      200: {
        content: {
          "application/json": components["schemas"]["AlertingFileExport"];
        };
      };
      /** PermissionDenied */
      403: {
        content: {
          "application/json": components["schemas"]["PermissionDenied"];
        };
      };
    };
  };
  RouteGetPolicyTree: {
    responses: {
      /** Route */
      200: {
        content: {
          "application/json": components["schemas"]["Route"];
        };
      };
    };
  };
  RoutePutPolicyTree: {
    parameters: {
      header: {
        "X-Disable-Provenance"?: string;
      };
    };
    responses: {
      /** Ack */
      202: {
        content: {
          "application/json": components["schemas"]["Ack"];
        };
      };
      /** ValidationError */
      400: {
        content: {
          "application/json": components["schemas"]["ValidationError"];
        };
      };
    };
    /** The new notification routing tree to use */
    requestBody: {
      content: {
        "application/json": components["schemas"]["Route"];
      };
    };
  };
  RouteResetPolicyTree: {
    responses: {
      /** Ack */
      202: {
        content: {
          "application/json": components["schemas"]["Ack"];
        };
      };
    };
  };
  RouteGetPolicyTreeExport: {
    responses: {
      /** AlertingFileExport */
      200: {
        content: {
          "application/json": components["schemas"]["AlertingFileExport"];
        };
      };
      /** NotFound */
      404: {
        content: {
          "application/json": components["schemas"]["NotFound"];
        };
      };
    };
  };
  RouteGetTemplates: {
    responses: {
      /** NotificationTemplates */
      200: {
        content: {
          "application/json": components["schemas"]["NotificationTemplates"];
        };
      };
      /** Not found. */
      404: unknown;
    };
  };
  RouteGetTemplate: {
    parameters: {
      path: {
        /** Template Name */
        name: string;
      };
    };
    responses: {
      /** NotificationTemplate */
      200: {
        content: {
          "application/json": components["schemas"]["NotificationTemplate"];
        };
      };
      /** Not found. */
      404: unknown;
    };
  };
  RoutePutTemplate: {
    parameters: {
      path: {
        /** Template Name */
        name: string;
      };
      header: {
        "X-Disable-Provenance"?: string;
      };
    };
    responses: {
      /** NotificationTemplate */
      202: {
        content: {
          "application/json": components["schemas"]["NotificationTemplate"];
        };
      };
      /** ValidationError */
      400: {
        content: {
          "application/json": components["schemas"]["ValidationError"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["NotificationTemplateContent"];
      };
    };
  };
  RouteDeleteTemplate: {
    parameters: {
      path: {
        /** Template Name */
        name: string;
      };
    };
    responses: {
      /** The template was deleted successfully. */
      204: never;
    };
  };
  /** You need to have a permission with action `settings:read` with scope `settings:auth.<provider>:*`. */
  listAllProvidersSettings: {
    responses: {
      200: components["responses"]["listSSOSettingsResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
    };
  };
  /** You need to have a permission with action `settings:read` with scope `settings:auth.<provider>:*`. */
  getProviderSettings: {
    parameters: {
      path: {
        key: string;
      };
    };
    responses: {
      200: components["responses"]["getSSOSettingsResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
    };
  };
  /**
   * Inserts or updates the SSO Settings for a provider.
   *
   * You need to have a permission with action `settings:write` and scope `settings:auth.<provider>:*`.
   */
  updateProviderSettings: {
    parameters: {
      path: {
        key: string;
      };
    };
    responses: {
      204: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      500: components["responses"]["internalServerError"];
    };
    requestBody: {
      content: {
        "application/json": {
          id?: string;
          provider?: string;
          settings?: { [key: string]: unknown };
        };
      };
    };
  };
  /**
   * Removes the SSO Settings for a provider.
   *
   * You need to have a permission with action `settings:write` and scope `settings:auth.<provider>:*`.
   */
  removeProviderSettings: {
    parameters: {
      path: {
        key: string;
      };
    };
    responses: {
      204: components["responses"]["okResponse"];
      400: components["responses"]["badRequestError"];
      401: components["responses"]["unauthorisedError"];
      403: components["responses"]["forbiddenError"];
      404: components["responses"]["notFoundError"];
      500: components["responses"]["internalServerError"];
    };
  };
}

export interface external {}
